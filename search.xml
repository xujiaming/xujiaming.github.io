<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[spring学习 基础装配 (spring in action 4th)]]></title>
      <url>http://mingcode.cn/2017/09/15/javaEE-SpringStudy-%E5%9F%BA%E7%A1%80%E8%A3%85%E9%85%8D/</url>
      <content type="html"><![CDATA[<blockquote>
<p>创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。在本章我们将介绍使用Spring装配 bean的基础知识。因为DI是Spring的最基本要素，所以在开发基于Spring的应用时，你随时都在使用这些技术。</p>
</blockquote>
<h2 id="spring配置的可选方案"><a href="#Spring配置的可选方案" class="headerlink" title="Spring配置的可选方案"></a>Spring配置的可选方案</h2><p>Spring具有非常大的灵活性，它提供了三种主要的装配机制：</p>
<ol>
<li>在XML中进行显式配置。</li>
<li>在Java中进行显式配置。</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>Spring的配置风格是可以互相搭配的，所以你可以选择使用XML装配一些bean，使用Spring基于Java的配置（JavaConfig）来装配另一些bean，而将剩余的bean让Spring去自动发现。<br>尽可能地使用自动配置的机制。显式配置越少越好。<br><a id="more"></a></p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring从两个角度来实现自动化装配：<br><br>组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。<br><br>自动装配（autowiring）：Spring自动满足bean之间的依赖。</p>
<h3 id="使用了component注解"><a href="#使用了-Component注解" class="headerlink" title="使用了@Component注解"></a>使用了@Component注解</h3><p>这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显式配置SgtPeppersbean，因为这个类使用了@Component注解，所以Spring会为你把事情处理妥当。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(<span class="string">"peppers"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String title = <span class="string">"Sgt. Pepper's 标题"</span>;</div><div class="line">    <span class="keyword">private</span> String artist = <span class="string">"The Beatles 作家"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"title:"</span>+title +<span class="string">"-----"</span> + <span class="string">"artist:"</span>+artist);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="开启自动扫描"><a href="#开启自动扫描" class="headerlink" title="开启自动扫描"></a>开启自动扫描</h3><p>组件扫描默认是不启用的。我们还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean。</p>
<h4 id="componentscan注解启用了组件扫描"><a href="#ComponentScan注解启用了组件扫描" class="headerlink" title="@ComponentScan注解启用了组件扫描"></a>@ComponentScan注解启用了组件扫描</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"></div><div class="line"><span class="comment">//设为配置类</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="comment">//组件扫描</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.xjm.test.test_2_2"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。@Configuration是 Spring 3.X 后提供的注解，用于取代 XML 来配置Spring的。<br><br> @Configuration注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。</p>
<p> <strong>basePackages = {“com.xjm.test.test_2_2”}</strong> 用来设置自动扫描路径</p>
<h4 id="xml来启用组件扫描"><a href="#XML来启用组件扫描" class="headerlink" title="XML来启用组件扫描"></a>XML来启用组件扫描</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.xjm.test.test_2_2"</span>/&gt;</span><span class="comment">&lt;!--开启自动扫描--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>**&lt;context:component-scan base-package=”com.xjm.test.test_2_2”/&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 为组件扫描的bean命名</div><div class="line">Spring应用上下文中所有的bean都会给定一个ID。没有明确地设置ID，Spring会根据类名为其指定一个ID。也就是将类名的第一个字母变为小写。列如：```@Component(&quot;peppers&quot;)```&lt;br&gt;</div><div class="line"></div><div class="line">还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范（Java Dependency Injection）中所提供的@Named注解来为bean设置ID,Spring支持将@Named作为@Component注解的替代方案。</div><div class="line"></div><div class="line">### 通过为bean添加注解实现自动装配</div><div class="line"></div><div class="line">自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以借助Spring的@Autowired注解。@Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上。</div><div class="line"></div><div class="line">```java </div><div class="line">import com.xjm.test.test_2_3.my_interface.CompactDisc;</div><div class="line"></div><div class="line">@Component</div><div class="line">public class CDPlayer &#123;</div><div class="line">    CompactDisc cdPlayer;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    public  CDPlayer(CompactDisc cdPlayer)&#123;</div><div class="line">        this.cdPlayer = cdPlayer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void play()&#123;</div><div class="line">        cdPlayer.play();</div><div class="line">    &#125;</div><div class="line">    @Autowired(required=false)</div><div class="line">    public void setCompactDisc(CompactDisc compactDisc) &#123;</div><div class="line">        this.cdPlayer = compactDisc;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异<br>常的出现，你可以将@Autowired的required属性设置为false</p>
<blockquote>
<p>注意 &gt; 1. 把required属性设置为false要进行null检查 2. 如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。</p>
</blockquote>
<p>Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p>
<h2 id="通过java代码装配bean"><a href="#通过Java代码装配bean" class="headerlink" title="通过Java代码装配bean"></a>通过Java代码装配bean</h2><p>在进行显式配置的时候，有两种可选方案：Java和XML。<br><br>在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。<br><br>JavaConfig是配置代码。这意味着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码之中。</p>
<h3 id="声明简单的bean"><a href="#声明简单的bean" class="headerlink" title="声明简单的bean"></a>声明简单的bean</h3><p>要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = &#123;<span class="string">"peppers"</span>&#125;)</div><div class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)  <span class="comment">//设置为原型模式</span></div><div class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管你采用什么方法来为bean命名，bean声明都是非常简单的。方法体返回了一个新的SgtPeppers实例。这里是使用Java来进行描述的，因此我们可以发挥Java提供的所有功能，只要最终生成一个CompactDisc实例即可。</p>
<h3 id="javaconfig实现依赖注入"><a href="#javaConfig实现依赖注入" class="headerlink" title="javaConfig实现依赖注入"></a>javaConfig实现依赖注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.xjm.test.test_2_3.my_interface.CompactDisc;</div><div class="line"><span class="keyword">import</span> com.xjm.test.test_2_3.my_interfaceImpl.SgtPeppers;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</div><div class="line"></div><div class="line"><span class="comment">//设为配置类</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span>(name = &#123;<span class="string">"peppers"</span>&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span>(name = <span class="string">"cdPlayer"</span> )</div><div class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">()</span></span>&#123;</div><div class="line">        CDPlayer cdPlayer = <span class="keyword">new</span> CDPlayer(sgtPeppers());</div><div class="line">        <span class="keyword">return</span> cdPlayer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此。因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，<strong>而不是每次都对其进行实际的调用</strong>。</p>
<p>默认情况下，Spring中的bean都是单例的,所以，Spring会拦截对sgtPeppers()的调用并确保返回的是Spring所创建的bean，也就是Spring本身在调用sgtPeppers()时所创建的CompactDiscbean。因此，两个CDPlayer bean会得到相同的SgtPeppers实例。</p>
<p>另外一种方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Bean</span>(name = <span class="string">"cdPlayer"</span> )</div><div class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc compactDisc)</span></span>&#123;</div><div class="line"><span class="comment">//        CompactDisc myCompact = new SgtPeppers();</span></div><div class="line">        CDPlayer cdPlayer = <span class="keyword">new</span> CDPlayer(compactDisc);</div><div class="line">        <span class="keyword">return</span> cdPlayer;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当Spring调用cdPlayer()<br>创建CDPlayerbean的时候，它会自动装配一个CompactDisc到配置方法之中。然后，方法体就可以按照合适的方式来使用它。借助这种技术，cdPlayer()方法也能够将CompactDisc注入到CDPlayer的构造器中，而且不用明确引用CompactDisc的@Bean方法。通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明</p>
<h2 id="通过xml装配bean"><a href="#通过XML装配bean" class="headerlink" title="通过XML装配bean"></a>通过XML装配bean</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</div><div class="line">          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peppers"</span> <span class="attr">class</span>=<span class="string">"com.xjm.test.test_2_4.my_interfaceImpl.SgtPeppers"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p><bean>元素类似于JavaConfig中的@Bean注解。</bean></p>
<p>没有明确给定ID，所以这个bean将会根据全限定类名来进行命名。在本例中，bean的ID将会是“soundsystem.SgtPeppers#0”。其中，“#0”是一个计数的形式，用来区分相同类型的其他bean。如果你声明了另外一个SgtPeppers，并且没有明确进行标识，那么它自动得到的ID将会是“soundsystem.SgtPeppers#1”。</p>
<h3 id="借助构造器注入初始化bean"><a href="#借助构造器注入初始化bean" class="headerlink" title="借助构造器注入初始化bean"></a>借助构造器注入初始化bean</h3><p>在XML中声明DI时，会有多种可选的配置方案和风格。具体到构造器注入，有两种基本的配置方案可供选择：</p>
<ol>
<li>&lt;constructor-arg&gt;元素</li>
<li>使用Spring 3.0所引入的c-命名空间</li>
</ol>
<h4 id="c-命名空间来声明构造器参数"><a href="#c-命名空间来声明构造器参数" class="headerlink" title="c-命名空间来声明构造器参数"></a>c-命名空间来声明构造器参数</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--c-命名空间来声明构造器参数--&gt;</span></div><div class="line">    xmlns:c="http://www.springframework.org/schema/c"</div><div class="line">    p:compactDisc-ref="peppers"</div></pre></td></tr></table></figure>
<p>属性名以“c:”开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后是“-ref”，这是一个命名的约定，它会告诉Spring，正在装配的是一个bean的引用，这个bean的名字是peppers，而不是字面量“peppers”。具体还有其他写法 — P74</p>
<ul>
<li>p命名空间实现list注入</li>
</ul>
<p>加入如下规则<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--util工具使用--&gt;</span></div><div class="line">    xmlns:util="http://www.springframework.org/schema/util</div><div class="line">    http://www.springframework.org/schema/util</div><div class="line">    http://www.springframework.org/schema/util/spring-util.xsd</div></pre></td></tr></table></figure></p>
<p>定义list or map 或者数组<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"peppersList"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"peppers"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"peppers"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"peppers"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>引入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--注入方式2 简写2 使用list--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdplayer"</span> <span class="attr">class</span>=<span class="string">"com.xjm.test.test_2_4.CDPlayer"</span> <span class="attr">c:songLists-ref</span>=<span class="string">"peppersList"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="使用ltconstructor-arg-gt来声明构造器参数"><a href="#使用-lt-constructor-arg-gt-来声明构造器参数" class="headerlink" title="使用&lt;constructor-arg &gt;来声明构造器参数"></a>使用&lt;constructor-arg &gt;来声明构造器参数</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">* 一般使用</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdplayer"</span> <span class="attr">class</span>=<span class="string">"com.xjm.test.test_2_4.CDPlayer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"peppers"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">* 注入数组集合</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdplayer"</span> <span class="attr">class</span>=<span class="string">"com.xjm.test.test_2_4.CDPlayer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> &gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"peppers"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>不过无论在哪种情况下，&lt;set&gt;或&lt;list&gt;都可以用来装配List、Set甚至数组。</p>
<p>在装配集合方面，&lt;constructor-arg&gt;比c-命名空间的属性更有优势。目前，使用c-命名空间的属性无法实现装配集合的功能。</p>
<h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><p>对强依赖使用构造器注入，而对可选性的依赖使用属性注入</p>
<ul>
<li>&lt;property&gt;设置属性</li>
</ul>
<p>&ltproperty;&gt;元素为属性的Setter方法所提供的功能与&lt;constructor-arg&gt;元素为构造器所提供的功能是一样的。</p>
<p>引入 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--p-命名空间来声明成员变量--&gt;</span></div><div class="line">xmlns:p="http://www.springframework.org/schema/p"</div></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdplayer"</span> <span class="attr">class</span>=<span class="string">"com.xjm.test.test_2_4.CDPlayer"</span> <span class="attr">p:compactDisc-ref</span>=<span class="string">"peppers"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"soundsystem.BlankDisc"</span></span></div><div class="line">    <span class="attr">p:title</span>=<span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span></div><div class="line">    <span class="attr">p:artist</span>=<span class="string">"The Beatles"</span></div><div class="line">    <span class="attr">p:tracks-ref</span>=<span class="string">"trackList"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>属性的名字使用了“p:”前缀，表明我们所设置的是一个属性。接下来就是要注入的属性名。最后，属性的名称以“-ref”结尾，这会提示Spring要进行装配的是引用，而不是字面量。将字面量注入到属性中属性也可以注入字面量，这与构造器参数非常类似。当然，如果在装配bean的时候不设置这些属性，那么在运行期将不能正常使用。</p>
<ul>
<li>&lt;property&gt;来注入属性 与构造器类似<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"soundsystem.BlankDisc"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">value</span>=<span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"artist"</span> <span class="attr">value</span>=<span class="string">"The Beatles"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tracks"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Sgt. Pepper's Lonely Hearts Club Band<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>With a Little Help from My Friends<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Lucy in the Sky with Diamonds<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Getting Better<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Fixing a Hole<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="util中其他属性"><a href="#util中其他属性" class="headerlink" title="util中其他属性"></a>util中其他属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">元 素 描 述</div><div class="line">util:constant        引用某个类型的 public static 域，并将其暴露为 bean</div><div class="line">util:list            创建一个 java.util.List 类型的 bean ，其中包含值或引用</div><div class="line">util:map             创建一个 java.util.Map 类型的 bean ，其中包含值或引用</div><div class="line">util:properties      创建一个 java.util.Properties 类型的 bean</div><div class="line">util:property-path   引用一个 bean 的属性（或内嵌属性），并将其暴露为 bean</div><div class="line">util:set             创建一个 java.util.Set 类型的 bean ，其中包含值或引用</div></pre></td></tr></table></figure>
<p>##混合配置</p>
<h3 id="在javaconfig中引用xml配置"><a href="#在JavaConfig中引用XML配置" class="headerlink" title="在JavaConfig中引用XML配置"></a>在JavaConfig中引用XML配置</h3><h4 id="在cdplayerconfig中使用import注解导入cdconfig"><a href="#在CDPlayerConfig中使用-Import注解导入CDConfig" class="headerlink" title="在CDPlayerConfig中使用@Import注解导入CDConfig"></a>在CDPlayerConfig中使用@Import注解导入CDConfig</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> soundsystem;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(CDConfig.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc compactDisc)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(compactDisc);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">或者导入多个</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(&#123;CDPlayerConfig.class, CDConfig.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundSystemConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用@ImportResource</li>
</ul>
<p>@ImportResource注解，假设BlankDisc定义在名为cd-config.xml的文件中，该文件位于根类路径下，那么可以修改SoundSystemConfig，让它使用@ImportResource注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(CDPlayerConfig.class)</div><div class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:cd-config.xml"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundSystemConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在xml配置中引用javaconfig"><a href="#在XML配置中引用JavaConfig" class="headerlink" title="在XML配置中引用JavaConfig"></a>在XML配置中引用JavaConfig</h3><ul>
<li>我们可以在XML配置文件中使用<import>元素来引用该文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"cd-config.xml"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDPlayer"</span> <span class="attr">c:cd-ref</span>=<span class="string">"compactDisc"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</import></li>
</ul>
<p>&lt;import&gt;元素只能导入其他的XML配置文件，并没有XML元素能够导入JavaConfig类。<br></p>
<p><bean>元素。为了将JavaConfig类导入到XML配置中，我们可以这样声明bean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDConfig"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDPlayer"</span> <span class="attr">c:cd-ref</span>=<span class="string">"compactDisc"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></bean></p>
<p>不管使用JavaConfig还是使用XML进行装配，我通常都会创建一个根配置（root<br>configuration），也就是这里展现的这样，这个配置会将两个或更多的装配类和/或XML文件<br>组合起来。我也会在根配置中启用组件扫描（通过&lt;context:component-scan&gt;<br>或@ComponentScan）。</p>
<p>建议尽可能使用自动化配置，以避免显式配置所带来的维护成本。但是，如果你确实<br>需要显式配置Spring的话，应该优先选择基于Java的配置，它比基于XML的配置更加强大、<br>类型安全并且易于重构。</p>
<h2 id="spring-测试方法"><a href="#spring-测试方法" class="headerlink" title="spring 测试方法"></a>spring 测试方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.xjm.test.test_2_4.CDPlayer;</div><div class="line"><span class="keyword">import</span> com.xjm.test.test_2_4.my_interface.CompactDisc;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertNotNull;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">//使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文</span></div><div class="line"><span class="comment">//加载配置，有两种方式通过类和配置文件</span></div><div class="line"><span class="comment">//@ContextConfiguration(locations = &#123;"classpath:test2_2_context.xml"&#125;)</span></div><div class="line"><span class="comment">//@ContextConfiguration(classes = &#123;CDPlayerConfig.class&#125;)</span></div><div class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:test_2_4_context.xml"</span>&#125;)</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest2_4</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    CompactDisc compactDisc;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> CDPlayer cd;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdSouldNotBeNull</span><span class="params">()</span></span>&#123;</div><div class="line">        compactDisc.play();</div><div class="line">        assertNotNull(cd);</div><div class="line">        cd.play();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> javaee </category>
            
            <category> spring </category>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaee spring 学习 基础装配 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础 异常(java编程思想)]]></title>
      <url>http://mingcode.cn/2017/09/01/javaBase-%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h3 id="异常结构图"><a href="#异常结构图" class="headerlink" title="异常结构图"></a>异常结构图</h3><img src="http://www.plantuml.com/plantuml/svg/oymhIIrAIqnELGZ9ACelJqpAIUM2inHiQlJq55oBYlABC0GhabCBIZBpyxZWBA24hgv2K6bUI6PkAbmK0000">
<a id="more"></a>
<p>Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>
<h3 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h3><blockquote>
<p>方式1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">// 异常的获取</span></div><div class="line">&#125; <span class="keyword">catch</span>(Type1 id1) &#123;</div><div class="line"><span class="comment">// 异常的处理1</span></div><div class="line">&#125; <span class="keyword">catch</span>(Type2 id2) &#123;</div><div class="line"><span class="comment">// 异常的处理2</span></div><div class="line">&#125; <span class="keyword">catch</span>(Type3 id3) &#123;</div><div class="line"><span class="comment">// 异常的处理3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>方式2</p>
</blockquote>
<p>   在方法末尾使用<strong>throws</strong>关键字<br><br>   在方法体内使用<strong>throw new *Exception(“msg”)</strong>的方式抛掷给使用它的客户处理<br><br>   例如：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"thrown from f()"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        f();</div><div class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>任何违例，它们都属于用new创建的、以内存堆为基础的对象，所以垃圾收集器会自动将其清除。</p>
</blockquote>
<h3 id="创建自己的违例"><a href="#创建自己的违例" class="headerlink" title="创建自己的违例"></a>创建自己的违例</h3><p>创建自己的违例类，必须从一个现有的违例类型继承——最好在含义上与新违例近似。<br><br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：</p>
<ol>
<li>覆盖一个方法时，只能产生已在方法的基础类版本中定义的违例。这是一个重要的限制，因为它意味着与基础类协同工作的代码也会自动应用于从基础类衍生的任何对象（当然，这属于基本的 OOP概念），其中包括违例。</li>
<li>一个方法的衍生类版本可以不产生任何违例——即便基础类版本要产生违例.</li>
<li>如我们上溯造型到基础类型，编译器就会强迫我们捕获针对基础类的违例.</li>
</ol>
</blockquote>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>论一个违例是否在try块中发生，我们都要执行一些特定的代码。这时就应该使用finally<br><br>使用方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 要保卫的区域：</span></div><div class="line">    <span class="comment">// 可能“掷”出 A,B,或C 的危险情况</span></div><div class="line">&#125; <span class="keyword">catch</span> (A a1) &#123;</div><div class="line">    <span class="comment">// 控制器 A</span></div><div class="line">&#125; <span class="keyword">catch</span> (B b1) &#123;</div><div class="line">    <span class="comment">// 控制器 B</span></div><div class="line">&#125; <span class="keyword">catch</span> (C c1) &#123;</div><div class="line">    <span class="comment">// 控制器 C</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 每次都会发生的情况</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="异常处理的缺陷提示可能会丢失"><a href="#异常处理的缺陷，提示可能会丢失" class="headerlink" title="异常处理的缺陷，提示可能会丢失"></a>异常处理的缺陷，提示可能会丢失</h4><p>下面是think in java中的一个例子：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryImportantException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A very important exception!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoHumException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A trivial exception"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostMessage</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> VeryImportantException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> VeryImportantException();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> <span class="keyword">throws</span> HoHumException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HoHumException();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        LostMessage lm = <span class="keyword">new</span> LostMessage();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lm.f();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lm.dispose();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">输出如下：</div><div class="line">A trivial exception</div><div class="line">    at LostMessage.dispose(LostMessage.java:<span class="number">21</span>)</div><div class="line">    at LostMessage.main(LostMessage.java:<span class="number">29</span>)</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，这里不存在 VeryImportantException（非常重要的违例）的迹象，它只是简单地被 finally从句中的HoHumException 代替了。这是一项相当严重的缺陷，因为它意味着一个违例可能完全丢失。而且就象前例演示的那样，这种丢失显得非常“自然”，很难被人查出蛛丝马迹。而与此相反，C++里如果第二个违例在第一个违例得到控制前产生，就会被当作一个严重的编程错误处理。或许Java 以后的版本会纠正这个问题（上述结果是用Java 1.8 生成的）。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 基础 </category>
            
            <category> 异常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java 异常 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础 数组—集合(java编程思想)]]></title>
      <url>http://mingcode.cn/2017/08/25/javaBase-%E6%95%B0%E7%BB%84_%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>定义和初始化</p>
</blockquote>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Gerbil[] arr = new Gerbil[10];</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   Gerbil[] arr2 = new Gerbil[]&#123;</div><div class="line">	new Gerbil(1),new Gerbil(2)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   Gerbil[] arr3 = &#123;</div><div class="line">	new Gerbil(1),new Gerbil(2)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>在jdk1.1和jdk1.2早期版中提供的基础版本有Java 提供了四种类型的“集合类”：Vector（矢量）、BitSet（位集）、Stack（堆栈）以及Hashtable（散列表）。<br></p>
<h4 id="vector单纯的一个容器类似现在的arraylist"><a href="#Vector单纯的一个容器类似现在的ArrayList" class="headerlink" title="Vector单纯的一个容器类似现在的ArrayList"></a>Vector单纯的一个容器类似现在的ArrayList</h4><blockquote>
<p>常用方法<br></p>
</blockquote>
<ul>
<li>Object elementAt(int postion)取得指定位置的元素</li>
<li>Enumeration elements() 获得对序列的一个“枚举”</li>
<li>add();</li>
<li>get(int pos);</li>
</ul>
<h4 id="stack-实现了一个-lifo先入先出序列"><a href="#Stack-实现了一个-LIFO（先入先出）序列" class="headerlink" title="Stack 实现了一个 LIFO（先入先出）序列"></a>Stack 实现了一个 LIFO（先入先出）序列</h4><ul>
<li>push() 压入</li>
<li>pop() 弹出</li>
<li>empty() 判空</li>
</ul>
<h4 id="hashtable-是一种关联数组允许我们将任何对象关联起来从-dictionary-继承"><a href="#Hashtable-是一种“关联数组”，允许我们将任何对象关联起来，从-Dictionary-继承。" class="headerlink" title="Hashtable 是一种“关联数组”，允许我们将任何对象关联起来，从 Dictionary 继承。"></a>Hashtable 是一种“关联数组”，允许我们将任何对象关联起来，从 Dictionary 继承。</h4><ul>
<li>put(Object key, Object value) 放入</li>
<li>remove(Object Key) 移除</li>
<li>get(Object key) 获得与某个键对应的值</li>
<li>keys() 产生对键的一个枚举（Enumeration）</li>
<li>elements() 产生对所有值的一个枚举</li>
<li>isEmpty() 判断是否包含了元素<h4 id="枚举器-enumeration"><a href="#枚举器-Enumeration" class="headerlink" title="枚举器 Enumeration"></a>枚举器 Enumeration</h4></li>
<li>hasMoreElements()</li>
<li>nextElement()<h4 id="反复器-迭代器-iterator"><a href="#反复器-迭代器-Iterator" class="headerlink" title="反复器 迭代器 Iterator"></a>反复器 迭代器 Iterator</h4></li>
</ul>
<h3 id="新集合"><a href="#新集合" class="headerlink" title="新集合"></a>新集合</h3><img src="http://www.plantuml.com/plantuml/svg/XLDBJWCn3DtFAIAndXu0LKXL5r2fh5f0BDsfWQXXfYH1g09kmPubT-0yI5o3EEaapdp4QYRllTZFTYnhY_eEAXJpHYcih6pgGaPmAOrbnnNoqoNisMdXVi0sciiRRN6RomAM1vetZtlGi57O1_E8v2ScWesn6YehAWN6YDdnIFb6A5RZYC8NFCAHwL7gwHbhAq7v086y0FFWp8YJSurOtw9IpGkZNBWXQgOr72XAJXR9kvY-JIPXD5sGBBRzIRBOCNBZKTwh2APnyR2E8CMf-Ftu_Fd-Ok4TmuHHm3DwaIycyLtF0yEXrZ1BL5LVbT_sxV2P-l1_Tob-JCb1rYP7bcKxqYAsAi1hDoY2subxS2dh7MxR6xrGYoqz67iO5TmWx4P98jP-OzBoY6bPdl6zOQMaMxokI501H1o_tG9yWzfHv3TuemDpxLhiaeTFW5OMgjs0DBxrBfVD8LkjOPWRzhAzImZtAAwiL4Qy5a8SDpQz0PD0xyCKxty0">
<h4 id="collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><blockquote>
<p>常用方法</p>
</blockquote>
<p>boolean add(Object) ＊保证集合内包含了自变量。如果它没有添加自变量，就返回 false（假）<br><br>boolean addAll(Collection) ＊添加自变量内的所有元素。如果没有添加元素，则返回 true（真）<br><br>void clear() ＊删除集合内的所有元素<br><br>boolean contains(Object) 若集合包含自变量，就返回“真”<br><br>boolean containsAll(Collection) 若集合包含了自变量内的所有元素，就返回“真”<br><br>boolean isEmpty() 若集合内没有元素，就返回“真”<br><br>Iterator iterator() 返回一个反复器，以用它遍历集合的各元素<br><br>boolean remove(Object) ＊如自变量在集合里，就删除那个元素的一个实例。如果已进行了删除，就返回“真”<br><br>boolean removeAll(Collection) ＊删除自变量里的所有元素。如果已进行了任何删除，就返回“真”<br><br>boolean retainAll(Collection) ＊只保留包含在一个自变量里的元素（一个理论的“交集”）。如果已进行了任何改变，就返回“真”<br><br>int size() 返回集合内的元素数量<br><br>Object[] toArray() 返回包含了集合内所有元素的一个数组<br></p>
<h4 id="list"><a href="#List" class="headerlink" title="List"></a>List</h4><blockquote>
<p>常用实现</p>
</blockquote>
<p>List（接口） 顺序是 List 最重要的特性；它可保证元素按照规定的顺序排列。<br></p>
<ul>
<li>ArrayList 由一个<strong>数组</strong>后推得到的 List。作为一个常规用途的对象容器使用，用于替换原先的Vector。允许我们<strong>快速访问元素</strong>，但在<strong>从列表中部插入和删除元素时，速度却嫌稍慢</strong>。一般只应该用ListIterator对一个ArrayList进行向前和向后遍历，<strong>不要用它删除和插入元素</strong></li>
<li>LinkedList 提供优化的顺序访问性能，同时可以高效率地在列表中部进行插入和删除操作。但在<strong>进行随机访问时，速度却相当慢</strong>，此时应换用 ArrayList。也提供了addFirst()，addLast()，getFirst()，getLast()，removeFirst()以及removeLast()，以便将其作为一个规格、队列以及一个双向队列使用.</li>
</ul>
<h4 id="set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol>
<li>Set拥有与 Collection完全相同的接口,没有什么额外的功能.</li>
<li>添加到 Set的每个元素都必须是独一无二的；否则Set就不会添加重复的元素。</li>
<li>添加到 Set里对象必须定义equals()，从而建立对象的唯一性。</li>
<li>Set不能保证自己可按任何特定的顺序维持自己的元素</li>
</ol>
<ul>
<li>HashSet  用于存非常小的以外的所有Set。对象也必须定义 hashCode()</li>
<li>ArraySet 由一个数组后推得到的 Set。面向非常小的Set设计，特别是那些需要频繁创建和删除的。对于小Set，与HashSet 相比，ArraySet 创建和反复所需付出的代价都要小得多。但随着 Set的增大，它的性能也会大打折扣。不需要HashCode()</li>
<li>TreeSet 由一个“红黑树”后推得到的顺序 Set。这样一来，我们就可以从一个Set 里提到一个顺序集合</li>
</ul>
<h4 id="map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li>HashMap 基于一个散列表实现（用它代替Hashtable）。针对“键－值”对的插入和检索，这种形式具有最稳定的性能。</li>
<li>ArrayMap 由一个 ArrayList后推得到的Map。对反复的顺序提供了精确的控制。面向非常小的 Map设计，特别是那些需要经常创建和删除的。对于非常小的Map，创建和反复所付出的代价要比 HashMap低得多。但在Map变大以后，性能也会相应地大幅度降低</li>
<li>TreeMap 在一个“红－黑”树的基础上实现。查看键或者“键－值”对时，它们会按固定的顺序排列（取决于Comparable 或Comparator，稍后即会讲到）。TreeMap最大的好处就是我们得到的是已排好序的结果。TreeMap是含有 subMap()方法的唯一一种Map，利用它可以返回树的一部分</li>
</ul>
<h3 id="arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul>
<li>Arrays.sort(array[]); //排序</li>
<li>Arrays.binarySearch(array[], array[pos]); //折半检索</li>
<li>Arrays.toString(aList)。//输出List<blockquote>
<p>对于基础数据类型binarySearch可以直接使用，若是对象，sort()和binarySearch()方法使用时，对象必须实现接口Comparable，或者在binarySearch传入第三个参数，一个实现Comparator接口的类。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>若在执行一次binarySearch()之前不调用 sort()，便会发生不可预测的行为，其中甚至包括无限循环。</p>
</blockquote>
<h3 id="collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><ul>
<li>拥有与 Arrays 中差不多的签名</li>
<li>sort(List)用于对一个实现了 Comparable的对象列表进行排序。</li>
<li>binarySearch(List,Object)用于查找列表中的某个对象。</li>
<li>sort(List,Comparator)利用一个“比较器”对一个列表进行排序。</li>
<li>binarySearch(List,Object,Comparator)则用于查找那个列表中的一个对象。</li>
<li>enumeration(Collection) 为自变量产生原始风格的Enumeration（枚举）</li>
<li>max(Collection)，min(Collection) 在自变量中用集合内对象的自然比较方法产生最大或最小元素</li>
<li>max(Collection,Comparator)，min(Collection,Comparator) 在集合内用比较器产生最大或最小元素</li>
<li>nCopies(int n, Object o) 返回长度为 n 的一个不可变列表，它的所有句柄均指向o</li>
</ul>
<h3 id="使-collection或-map不可修改"><a href="#使-Collection或-Map不可修改" class="headerlink" title="使 Collection或 Map不可修改"></a>使 Collection或 Map不可修改</h3><ul>
<li>创建 Collection或 Map的一个“只读”版本显得更有利一些</li>
<li>Collections.unmodifiableCollection(c);</li>
<li>Collections.unmodifiableList(a);</li>
<li>Collections.unmodifiableSet(s);</li>
<li>Collections.unmodifiableMap(m);</li>
</ul>
<h3 id="collection-或map-的同步"><a href="#Collection-或Map-的同步" class="headerlink" title="Collection 或Map 的同步"></a>Collection 或Map 的同步</h3><ul>
<li>Collection c = Collections.synchronizedCollection(new ArrayList());</li>
<li>List list = Collections.synchronizedList(new ArrayList());</li>
<li>Set s = Collections.synchronizedSet(new HashSet());</li>
<li>Map m = Collections.synchronizedMap(new HashMap());</li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 基础 </category>
            
            <category> 数组 集合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java 数组 集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring学习 环境搭建练习]]></title>
      <url>http://mingcode.cn/2017/08/03/javaEE-SpringStudy-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%BB%83%E4%B9%A0/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> javaee </category>
            
            <category> spring </category>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaee spring 学习 搭建 maven oracle mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[培训笔记 银海 oracle]]></title>
      <url>http://mingcode.cn/2017/07/14/%E9%93%B6%E6%B5%B7%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0-oracle/</url>
      <content type="html"><![CDATA[<h3 id="expimp数据导入导出"><a href="#（exp-imp）数据导入导出" class="headerlink" title="（exp/imp）数据导入导出"></a>（exp/imp）数据导入导出</h3><p> 是在cmd命令下，而不是sqlplus中。</p>
<h4 id="数据导出exp"><a href="#数据导出-exp" class="headerlink" title="数据导出(exp)"></a>数据导出(exp)</h4><ol>
<li><p>完全导出 导出到D:\zjgl.dmp </p>
<figure class="highlight plain"><figcaption><span>system/root@ORCL file=d:\orcl.dmp full=y```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    将数据库orcl完全导出，full=y 表示全库导出，缺省情况下full=no，这时只会将该用户下的对象导出。system/root一定要有dba权限</div><div class="line"></div><div class="line">2. 将数据库orcl中zjgl用户与scott用户的表导出</div><div class="line"></div><div class="line">    ``` exp system/root@ORCL file=d:\zjgl_scott.dmp owner=(zjgl,scott)</div></pre></td></tr></table></figure>
<p> full方式可以备份所有用户的数据库对象，包括表空间、用户信息等，owner=XX只能备份指定用户的对象，其他用户下的就不备份了，EXP中full=y和owner=XX是不能同时使用的。</p>
<a id="more"></a>
</li>
<li><p>将数据库orcl中的表t_users导出</p>
<figure class="highlight plain"><figcaption><span>system/root@ORCL file= d:\t_users.dmp tables=(t_users)```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    tables=xx 表示备份相关表，不能同时和owner、full使用。....更多操作百度。</div><div class="line"></div><div class="line">#### 数据导入(imp)</div><div class="line"></div><div class="line"></div><div class="line">1. 将D:\test.dmp 中的数据导入 test数据库中。</div><div class="line">    imp system/root@test file=D:\test.dmp</div><div class="line">导数据得时候，有可能报错。为什么？有以下主要的原因：</div><div class="line"></div><div class="line">   A. 导入的对象（表，视图，方法等）原本不属于当前连接的用户的&lt;br&gt;</div><div class="line">   B. 导入的对象在该数据库的指定用户下已经存在&lt;br&gt;</div><div class="line">   C. 导入的对象的原本用户不在这个数据库里&lt;br&gt;</div><div class="line">解决 </div><div class="line"></div><div class="line">2. 所有对象全部导入到指定的账户下：</div><div class="line">    ``` imp system/root@ORCL file=d:\test.dmp fromuser=zjgl touser=zjgl_new</div></pre></td></tr></table></figure>
<p> 其中fromuser=zjgl为.dmp文件里的对象的原先的owner, touser=zjgl_new为作为导入的对象的新的Owner.</p>
</li>
<li><p>忽略/插入数据：</p>
 <figure class="highlight plain"><figcaption><span>system/root@ORCL file=d:\test.dmp ignore=y```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其中ignore=y告诉imp.exe把数据直接插入到相应对象（并且如果导入的对象里面有其他的对象，如约束，索引等，会在数据插入后被创建）。</div><div class="line"></div><div class="line">4. 将d:\test.dmp中的表test1 导入</div><div class="line">    ```imp system/root@ORCL file=d:\test.dmp tables=(test1)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="expdpimpdp数据泵导入导出"><a href="#expdp-impdp-数据泵导入导出" class="headerlink" title="(expdp/impdp)数据泵导入导出"></a>(expdp/impdp)数据泵导入导出</h3><p>使用expdp和impdp时应该注重的事项：</p>
<ol>
<li>exp和imp是客户端工具程序，它们既可以在客户端使用，也可以在服务端使用。</li>
<li>expdp和impdp是服务端的工具程序，他们只能在oracle服务端使用，不能在客户端使用。</li>
<li>imp只适用于exp导出的文件，不适用于expdp导出文件；impdp只适用于expdp导出的文件，而不适用于exp导出文件。</li>
<li><p>对于10g以上的服务器，使用exp通常不能导出0行数据的空表，而此时必须使用expdp导出。</p>
<p> 一 <figure class="highlight plain"><figcaption><span>sys/root@orcl as sysdba``` 登录dba用户<br></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    二 创建操作目录 ```create directory caozuo as &apos;R:\daochu&apos;;```&lt;br&gt;</div><div class="line">    三 查询是否存在 ```select * from dba_directories;```&lt;br&gt;</div><div class="line">    四 退出 sqlplus</div><div class="line"></div><div class="line">#### 导出</div><div class="line">1. 导出用户</div><div class="line">```expdp scott/tiger@orcl schemas=scott dumpfile=scott.dmp directory=caozuo logfile=expdb.log;</div></pre></td></tr></table></figure></p>
<p>  导出日志必须有<strong>logfile=expdb.log</strong>，主要<strong>schemas=scott</strong></p>
</li>
<li><p>导出表</p>
<figure class="highlight plain"><figcaption><span>scott/tiger@orcl tables=emp,dept dumpfile=scott_emp_dept.dmp directory=caozuo logfile=expdb2.log;``</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     主要**tables=emp,dept**</div><div class="line"></div><div class="line">3. 按查询条件导```expdp scott/tiger@orcl directory=caozuo dumpfile=expdp_where.dmp tables=emp query=&apos;where deptno=20&apos;;</div></pre></td></tr></table></figure>
<p>  <strong>query=’where deptno=20’</strong></p>
</li>
<li>按表空间导</li>
</ol>
<figure class="highlight plain"><figcaption><span>scott/tiger@orcl directory=caozuo dumpfile=tablespace.dmp tablespaces=temp,example```;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">**tablespaces=temp,example**</div><div class="line"></div><div class="line">5. 导整个数据库</div><div class="line">```expdp scott/tiger@orcl directory=caozuo dumpfile=full.dmp full=y;</div></pre></td></tr></table></figure>
<p><strong>full=y</strong></p>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><ol>
<li>导入用户（从用户scott导入到用户scott）</li>
</ol>
<figure class="highlight plain"><figcaption><span>scott/tiger@orcl directory=caozuo dumpfile=expdp.dmp ```**schemas=scott**;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 导入表（从scott用户中把表dept和emp导入到system用户中）</div><div class="line"></div><div class="line">```impdp system/manager@orcl directory=caozuo dumpfile=expdp.dmp`` </div><div class="line">    **tables=scott.dept,scott.emp remap_schema=scott:system**;</div><div class="line"></div><div class="line">3. 导入表空间</div><div class="line"></div><div class="line">```impdp system/manager@orcl directory=caozuo dumpfile=tablespace.dmp ```**tablespaces=example**;</div><div class="line"></div><div class="line">4. 导入数据库</div><div class="line"></div><div class="line">```impdb system/manager@orcl directory=caozuo dumpfile=full.dmp``` **full=y**;</div><div class="line"></div><div class="line">5. 追加数据</div><div class="line">```impdp system/manager@orcl directory=caozuo dumpfile=expdp.dmp``` **schemas=system table_exists_action**</div><div class="line"></div><div class="line">### 函数</div><div class="line">#### 单行函数</div><div class="line">```coalesce(arg,arg1,...)``` 从左侧开始，第一个不为空的值&lt;br&gt;</div><div class="line">```nullif(A,B)```A和B相等返回NULL,否则返回A&lt;br&gt;</div><div class="line">```rtrim()```将右边的空格压缩类似ltrim()&lt;br&gt;</div><div class="line">```select NEXT_DAY(sysdate,&apos;星期五&apos;) from dual;``` &lt;br&gt;</div><div class="line">```trunc(sysdate,&apos;hh24&apos;)</div></pre></td></tr></table></figure>
<h4 id="11g新函数"><a href="#11g新函数" class="headerlink" title="11g新函数"></a>11g新函数</h4><p>分组函数 可使用over()函数；示范：<code>select ename,deptno,avg(sal) over(partition by deptno) avgsal from emp;</code><br>Pivot 和 unpivot语法     <code>`http://blog.csdn.net/tianlesoftware/article/details/7060306</code></p>
]]></content>
      
        <categories>
            
            <category> 培训 </category>
            
            <category> 银海 </category>
            
            <category> oracle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 培训笔记 oracle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring学习 概述 (spring in action 4th)]]></title>
      <url>http://mingcode.cn/2017/07/14/javaEE-SpringStudy-spring%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring是一个开源框架，最早由Rod Johnson创建，并在《Expert One-on-One：J2EE Design andDevelopment》<br><a href="http://amzn.com/076454385" target="_blank" rel="external">地址</a>  这本著作中进行了介绍。Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖<br>于它的两个核心特性，也就是<strong>依赖注入</strong>（dependency injection，<strong>DI</strong>）和<strong>面向切面编程</strong>（aspect-oriented programming，<strong>AOP</strong>）。</p>
<p></p><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p>
<ol>
<li>基于POJO的轻量级和最小侵入性编程；</li>
<li>通过依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>通过切面和模板减少样板式代码</li>
</ol>
<p>Spring竭力避免因自身的API而弄乱你的应用代码。Spring不会强迫你实现Spring规范的接口<br>或继承Spring规范的类，相反，在基于Spring构建的应用中，它的类通常没有任何痕迹表明<br>你使用了Spring。<br><a id="more"></a></p>
<h3 id="控制反转inversion-of-control"><a href="#控制反转-Inversion-of-Control" class="headerlink" title="控制反转(Inversion of Control)"></a>控制反转(Inversion of Control)</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p>IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：<1>依赖查找（Dependency Lookup）：容器提供回调接口和上下文环境给组件。<2>依赖注入（Dependency Injection）：组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</2></1></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    Father father;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;</div><div class="line">        father = <span class="keyword">new</span> Father();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码；</li>
<li>如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；</li>
<li>如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。</li>
</ol>
<h4 id="依赖注入"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    Father father;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(Father father)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.father = father;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种<strong>非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入</strong>。</p>
<p>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：(1). 解耦，将依赖之间解耦。(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</p>
<p>有接口注入（Interface Injection），设值注入（Setter Injection）和构造子注入（Constructor Injection）三种方式</p>
<p>在spring中可以通过xml文件，注解和java文件进行实现。</p>
<p>依赖注入优点：<1>查找定位操作与应用代码完全无关。<2>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。<3>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</3></2></1></p>
<h3 id="应用切面"><a href="#应用切面" class="headerlink" title="应用切面"></a>应用切面</h3><p>动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-orientedprogramming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</p>
<h3 id="spring容器containerp38"><a href="#Spring容器（container）P38" class="headerlink" title="Spring容器（container）P38"></a>Spring容器（container）<em>P38</em></h3><p>在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。如图1.4所示，Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是new到finalize()）。</p>
<p>Spring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。<strong>bean工厂（由org.springframework. beans. factory.eanFactory接口定义）是最简单的容器</strong>，提供基本的DI支持。<strong>应用上下文（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建</strong>，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。——–主要使用应用上下文。</p>
<h4 id="使用应用上下文"><a href="#使用应用上下文" class="headerlink" title="使用应用上下文"></a>使用应用上下文</h4><p>Spring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的。<br><br>AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。<br><br><strong>AnnotationConfigWebApplicationContext</strong>：从一个或多个基于Java的配置类中加载Spring Web应用上下文。<br><br>ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。<br><br>FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。<br><br><strong>XmlWebApplicationContext</strong>：从Web应用下的一个或多个XML配置文件中加载上下文定义。</p>
<p>例子：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml");</div><div class="line">    ApplicationContext context = new ClassPathXmlApplicationContext("knight.xml");</div><div class="line">    ``` </div><div class="line"></div><div class="line">使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：FileSystemXmlApplicationContext在指定的文件系统路径下查找knight.xml文件；而ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件）下查找knight.xml文件。</div><div class="line"></div><div class="line">如果你想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext：</div><div class="line">```java </div><div class="line">ApplicationContext context = new AnnotationConfigApplicationContext(com.springinaction.</div><div class="line">                                knights.config.KnightConfig.class);</div><div class="line">``` </div><div class="line"></div><div class="line">### bean的生命周期</div><div class="line"></div><div class="line">1. Spring对bean进行实例化；</div><div class="line">2. Spring将值和bean的引用注入到bean对应的属性中；</div><div class="line">3. 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</div><div class="line">4. 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</div><div class="line">5. 果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</div><div class="line">6. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</div><div class="line">7. 如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</div><div class="line">8. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</div><div class="line">9. 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</div><div class="line">10. 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</div><div class="line"></div><div class="line">写个例子：有三个java文件OneBean.java,PostService.java,Test.java,还有个上下文依赖关系文件applicationContext.xml</div><div class="line"></div><div class="line">**applicationContext.xml**</div><div class="line">```xml</div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">       xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">       xmlns:aop="http://www.springframework.org/schema/aop"  </div><div class="line">       xmlns:p="http://www.springframework.org/schema/p" </div><div class="line">    xsi:schemaLocation="  </div><div class="line">    http://www.springframework.org/schema/context  </div><div class="line">    http://www.springframework.org/schema/context/spring-context.xsd  </div><div class="line">    http://www.springframework.org/schema/beans  </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd  </div><div class="line">    http://www.springframework.org/schema/aop  </div><div class="line">    http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; </div><div class="line">    </div><div class="line">    &lt;bean id="oneBean" class="com.bean.life.OneBean" init-method="myInit" destroy-method="myDestroy" &gt;</div><div class="line">        &lt;property name="beanName1" value="555"&gt;&lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;bean id="postService" class="com.bean.life.PostService"&gt;&lt;/bean&gt;</div><div class="line">   &lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p><strong>OneBean.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bean.life;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</div><div class="line"></div><div class="line"><span class="comment">//如果设置了init-method="myInit" destroy-method="myDestroy" </span></div><div class="line"><span class="comment">//两个方法（推荐使用）就不需要实现InitializingBean,DisposableBean</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneBean</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> ,<span class="title">BeanFactoryAware</span>,</span></div><div class="line">        <span class="title">ApplicationContextAware</span>,<span class="title">InitializingBean</span>,<span class="title">DisposableBean</span>  &#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String beanName1 = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanName1</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> beanName1;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName1</span><span class="params">(String beanName1)</span> </span>&#123;<span class="keyword">this</span>.beanName1 = beanName1;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">OutName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> beanName1;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OneBean</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"（1）我是OneBean的构造函数"</span>);</div><div class="line">		System.out.println(beanName1);</div><div class="line">	&#125;	</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（2）将被设置的bean名称！"</span>+name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory arg0)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"-------------------------------------------------"</span>);</div><div class="line">		System.out.println(<span class="string">"（3）OneBean实现BeanFactoryAware后得到FactoryBean"</span></div><div class="line">                          + <span class="string">"(在OneBean.java输出)："</span>+arg0);</div><div class="line">		System.out.println(<span class="string">"    FactoryBean得到的OneBean与this本身相等："</span></div><div class="line">                                +(arg0.getBean(<span class="string">"oneBean"</span>) == <span class="keyword">this</span>));</div><div class="line">		System.out.println(<span class="string">"    "</span>+beanName1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"------------------------------------------------"</span>);</div><div class="line">		System.out.println(<span class="string">"（4）OneBean实现ApplicationContextAware后得到ApplicationContext"</span></div><div class="line">                           +<span class="string">" (在OneBean.java输出)："</span>+applicationContext);</div><div class="line">		System.out.println(<span class="string">"    ApplicationContext得到的OneBean与this本身相等："</span></div><div class="line">                            +(applicationContext.getBean(<span class="string">"oneBean"</span>) == <span class="keyword">this</span>));</div><div class="line">		System.out.println(<span class="string">"    "</span>+beanName1);</div><div class="line">		System.out.println(<span class="string">"---------------------------------------------------"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（6）运行afterPropertiesSet()方法"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"（7）执行自己定义初始化的方法myInit()（需要在xml里面配置）"</span>);&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestroy</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"（10）执行自己定义Destroy()方法（需要在xml里面配置）"</span>);&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（9）执行destroy()方法"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>PostService.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bean.life;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostService</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		 System.out.println(<span class="string">"（5）---这是init之前执行的方法postProcessBeforeInitialization---"</span>);</div><div class="line">		 </div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（8）----这是init之后执行的方法postProcessAfterInitialization----"</span>);</div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Test.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bean.life;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.AbstractApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.service.ApplicationContextUtil;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"main---初始化之前！"</span>);</div><div class="line">		ApplicationContext applicationContext = ApplicationContextUtil.getAc();</div><div class="line">		System.out.println(<span class="string">"main---得到applicationContext后！"</span>);</div><div class="line">		OneBean oneBean = (OneBean) applicationContext.getBean(<span class="string">"oneBean"</span>);</div><div class="line">		System.out.println(<span class="string">"OneBean中的OutName方法调用："</span>+oneBean.OutName());</div><div class="line">		AbstractApplicationContext aac =(AbstractApplicationContext) applicationContext;</div><div class="line">		aac.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>执行结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">main---初始化之前！</div><div class="line">七月 14, 2017 4:19:48 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh</div><div class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy</div><div class="line">七月 14, 2017 4:19:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</div><div class="line">信息: Loading XML bean definitions from class path resource [applicationContext.xml]</div><div class="line">（1）我是OneBean的构造函数</div><div class="line">null</div><div class="line">（2）将被设置的bean名称！oneBean</div><div class="line">-------------------------------------------------------------------------</div><div class="line">（3）OneBean实现BeanFactoryAware后得到FactoryBean(在OneBean.java输出)：org.springframework.beans.factory.support.DefaultListableBeanFactory@b44eaa0: defining beans [oneBean,postService]; root of factory hierarchy</div><div class="line">    FactoryBean得到的OneBean与this本身相等：true</div><div class="line">    555</div><div class="line">---------------------------------------------------------------------------</div><div class="line">（4）OneBean实现ApplicationContextAware后得到ApplicationContext(在OneBean.java输出)：org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy</div><div class="line">    ApplicationContext得到的OneBean与this本身相等：true</div><div class="line">    555</div><div class="line">---------------------------------------------------------------------------</div><div class="line">（5）---这是init之前执行的方法postProcessBeforeInitialization---</div><div class="line">（6）运行afterPropertiesSet()方法</div><div class="line">（7）执行自己定义初始化的方法myInit()（需要在xml里面配置）</div><div class="line">（8）----这是init之后执行的方法postProcessAfterInitialization----</div><div class="line">main---得到applicationContext后！</div><div class="line">OneBean中的OutName方法调用：555</div><div class="line">七月 14, 2017 4:19:48 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose</div><div class="line">信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy</div><div class="line">（9）执行destroy()方法</div><div class="line">（10）执行自己定义Destroy()方法（需要在xml里面配置）</div></pre></td></tr></table></figure></p>
<h3 id="spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h3><p>Spring框架由6个定义良好的模块分类组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Data access &amp; integration</div><div class="line">  |----JDBC</div><div class="line">  |----OXM</div><div class="line">  |----Messaging</div><div class="line">  |----Transaction</div><div class="line">  |----ORM</div><div class="line">  |----JMS</div><div class="line"></div><div class="line">Web and remoting           \\Web与远程调用</div><div class="line">  |----Web </div><div class="line">  |----Web servlet</div><div class="line">  |----Web portlet</div><div class="line">  |----WebSocket</div><div class="line"></div><div class="line">Aspect-oriented programming  \\Spring的AOP模块</div><div class="line">  |----AOP</div><div class="line">  |----Aspects</div><div class="line"></div><div class="line">Instrumentation</div><div class="line">  |----Instrument Tomcat</div><div class="line">  |----Instrument</div><div class="line"></div><div class="line">Core Spring container        \\Spring核心容器</div><div class="line">  |----Beans</div><div class="line">  |----Core </div><div class="line">  |----Context </div><div class="line">  |----Expression</div><div class="line">  |----Context support</div><div class="line">Testing</div><div class="line">  |----Test</div></pre></td></tr></table></figure></p>
<ol>
<li>核心容器（Core Spring container ）</li>
</ol>
<ul>
<li>spring-core和spring-beans：提供框架的基础部分，包括控制反转和依赖注入的特性，BeanFactory是用工厂模式来实现的，使我们不用自己去创建单例对象，并将依赖的配置和设计与业务逻辑分开来。</li>
<li>spring-context模块是建立在前两者之上的，通过它可以使用框架风格（framework-style）的方法来访问对象，类似于JNDI服务注册。该模块集成了bean模块，并加入了国际化、事件传播、资源加载、透明化生成上下文，还支持Java EE特性如EJB、 JMX 和 basic remoting。context模块的关键是ApplicationContext接口。spring-context-support支持集成第三方库，如缓存、邮件、调度、模板引擎等。</li>
<li>spring-expression: 提供了强大的EL（ expression language）在运行状态查询和操纵对象，它支持属性的赋值，通过setter和getter方法设置和获取属性值、方法调用、访问数组 集合、逻辑和数学操纵、变量命名、通过IoC容器检索对象。</li>
</ul>
<ol>
<li>AOP和插装(Aspect-oriented programming )</li>
</ol>
<ul>
<li>spring-aop :模块提供了面向切面编程的实现，使我们可以定义方法拦截器和切点来使得分离功能独立的业务。使用基于源的元数据功能，我们还可以将行为信息集成到代码中，这和.NET的属性很相似。</li>
<li>spring-aspects :模块支持Spring 框架整合AspectJ.</li>
<li>spring-instrument 在特定容器中实现类插装和类加载器的实施 。 spring-instrument-tomcat包含Tomcat的Spring插装代理。</li>
</ul>
<ol>
<li>消息(Messaging)</li>
</ol>
<ul>
<li>spring-messaging 模块包含从 Message，MessageChannel，MessageHandler 等其他基于消息的基础应用中得到的抽象。该模块还包含一系列的注解来讲消息映射到方法上，和SpringMVC注解类似 。</li>
</ul>
<ol>
<li>数据访问控制(Data access &amp; integration)</li>
</ol>
<ul>
<li>spring-jdbc提供JDBC抽象层 ，使我们从繁重的JDBC编程中解脱出来，并且不再需要为解析不同的数据库的异常而烦恼。</li>
<li>spring-tx支持对所有POJO和实现了特定接口的类进行 编程式和申明式事务（ programmatic and declarative transaction ）管理。</li>
<li>spring-orm整合了流行的ORM（object-relational mapping ）应用程序接口，包括JPA、JDO和Hibernate。使用该模块我们可以任意使用这些ORM框架和Spring的其他功能（如上面的申明式事务管理进行组合。</li>
<li>spring-oxm为OXM（Object/XML mapping） 的实现提供抽象层，如 JAXB、Castor、XMLBeans、JiBX 和XStream。</li>
<li>spring-jms 是Java消息服务(Java Messaging Service)，包含产生和接受消息 。Spring Framework 4.1将它并入在spring-messaging 模块。</li>
</ul>
<ol>
<li>Web(Web and remoting)</li>
</ol>
<ul>
<li>spring-web 包含基本的面向网络的集成特性，如文件分部上传，使用Servet监听器和面向网络的应用上下文初始化IoC容器。他还包括 HTTP 客户端和网络相关的 Spring远程支持。</li>
<li>spring-webmvc 也被成为 Web-Servlet 模块，包含Spring的模型-视图-控制器（model-view-controller，MVC) 和 REST Web Services。 Spring  MVC 框架是得实体模型代码和网络表单清楚地离开来，还可以轻松集成Spring框架的其他特性。</li>
<li>spring-webmvc-portlet 也被称为 Web-Portlet 模块，在Portlet 容器中实现MVC，并且能使用spring-webmvc 模块的功能。</li>
</ul>
<ol>
<li>测试(Testing)</li>
</ol>
<ul>
<li>spring-test 模块支持单元测试 JUnit 、集成测试 TestNG和独立代码测试 mock objects。它支持加载和缓存 Spring ApplicationContexts。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaee </category>
            
            <category> spring </category>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaee spring 学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础 多形性[多态](java编程思想)]]></title>
      <url>http://mingcode.cn/2017/06/13/javaBase-%E5%A4%9A%E5%BD%A2%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="多形性多态"><a href="#多形性（多态）：" class="headerlink" title="多形性（多态）："></a>多形性（多态）：</h3><p><blockquote class="blockquote-center"><pre><br>“对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。)”<br>“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与<br>“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建<br>“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成<br>长”。                                                 ——–think in java<br>    </pre><br></blockquote><br><a id="more"></a></p>
<h3 id="具体知识点"><a href="#具体知识点" class="headerlink" title="具体知识点"></a>具体知识点</h3><h4 id="上溯造型"><a href="#上溯造型" class="headerlink" title="上溯造型"></a>上溯造型</h4><p>以一个简单的例子说明，类图如下：<br><img src="http://www.plantuml.com/plantuml/svg/IquiKh2fqTLLI2mjoS_DJyhCIULA1efPARnOsFDovJODJIw4398e0000"><br>在上面的例子中，automobile继承自car，因为继承树的画法是基础类位于最上方，所以称之为上溯造型。我们可以知道automobile是car的子类。所以可以这样定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">car sub = <span class="keyword">new</span> automobile();</div></pre></td></tr></table></figure>
<p>通过基础类的句柄可以调用子类的方法。</p>
<p>以下有一个利用上溯造型的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Note</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; value = val; &#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Note</div><div class="line">    middleC = <span class="keyword">new</span> Note(<span class="number">0</span>),</div><div class="line">    cSharp = <span class="keyword">new</span> Note(<span class="number">1</span>),</div><div class="line">    cFlat = <span class="keyword">new</span> Note(<span class="number">2</span>);</div><div class="line">&#125; <span class="comment">// Etc.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Instrument.play()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Wind objects are instruments</span></div><div class="line"><span class="comment">// because they have the same interface:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</div><div class="line"><span class="comment">// Redefine interface method:</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Wind.play()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">        i.play(Note.middleC);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Wind flute = <span class="keyword">new</span> Wind();</div><div class="line">        tune(flute); <span class="comment">// Upcasting</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>有一个问题：</strong> 编译器怎样才能知道 Instrument句柄指向的是一个 Wind，而不是一个Brass 或Stringed 呢？</p>
</blockquote>
<p>这里就涉及到了方法调用的绑定了，java主要是使用“后期绑定”，后期绑定也叫作“动态绑定”或“运行期绑定”。<br><br>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。<br><br>Java 中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成<code>final</code>。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。为什么要把一个方法声明成final 呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，<code>它可有效地“关闭”动态绑定</code>，或者告诉编译器不需要进行动态绑定。这样一来，<code>编译器就可为final 方法调用生成效率更高的代码</code>。</p>
<h4 id="覆盖与过载"><a href="#覆盖与过载" class="headerlink" title="覆盖与过载"></a>覆盖与过载</h4><p>“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。过载时返回值和参数数量，参数类型顺序不同，覆盖是返回值和参数完全一致。</p>
<h4 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h4><ul>
<li>包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。</li>
<li>如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为<code>基础类中的所有抽象方法提供方法定义</code>。如果<code>不这样做</code>（完全可以选择不做），则衍生类也会是抽象的，而且编译器会<code>强迫我们用abstract关键字标志</code>那个类的“抽象”本质。</li>
<li>即使<code>不包括任何abstract 方法</code>，亦可将一个类声明成“抽象类”。如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。</li>
</ul>
<p>以下用个图来说明<br><img src="http://www.plantuml.com/plantuml/svg/yymhBYagpKtDAr6mgT7LLGZFp4lXuafC0eec9fSe9ESa5XShUC8LLNCf085sDKn1hK9PVcQAGa5EOgL6fe8LK6L9QdfgaQOrLoqN5qGpo4IeDfng0G00"></p>
<p>上面就是一个继承关系,Wind属于Instrument，Wind实现了play方法。Instrument只是一个种类的抽象，定义了部分方法，没有实现，它不能具体实例化，但可以像下面的形式使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instrument wind = <span class="keyword">new</span> Wind();</div><div class="line">wind.play(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote><p>“interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：<em>方法名、自变量列表以及返回类型，但不规定方法主体</em>。接口也包含了基本数据类型的数据成员，但它们都<mark>默认为static 和final</mark>。接口只提供一种形式，并不提供实施的细节。</p>
<footer><strong>think in java</strong></footer></blockquote>
<ul>
<li><p>可将一个接口中的方法声明明确定义为“public”。但即便不明确定义，它们也会默认为 public。所以在实现一个接口的时候，来自接口的方法必须定义成public。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java 编译器不允许我们那样做。</p>
</li>
<li><p>创建一个新类时，可以上溯到它所实现的接口上面。</p>
</li>
<li><p>关于<code>&quot;多继承&quot;(P175)</code></p>
<p>如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于 implements关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面有个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;&#125;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span></span></div><div class="line"><span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">CanFly</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span> </span>&#123; x.fight(); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span> </span>&#123; x.swim(); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(CanFly x)</span> </span>&#123; x.fly(); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionCharacter x)</span> </span>&#123; x.fight(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Hero i = <span class="keyword">new</span> Hero();</div><div class="line">        t(i); <span class="comment">// Treat it as a CanFight</span></div><div class="line">        u(i); <span class="comment">// Treat it as a CanSwim</span></div><div class="line">        v(i); <span class="comment">// Treat it as a CanFly</span></div><div class="line">        w(i); <span class="comment">// Treat it as an ActionCharacter</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>当继承和接口实现中出现相同的方法标签<code><mark>fight()</mark></code>(在ActionCharacter类和CanFight接口中)，接口的可以从继承中实现。</li>
<li><p>上述例子已向我们揭示了接口最关键的作用，也是使用接口最重要的一个原因：能上溯造型至多个基础类。</p>
<blockquote>
<ul>
<li><em>这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？</em></li>
</ul>
</blockquote>
</li>
<li><p>若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类</p>
</li>
</ol>
<ul>
<li><p>通过继承扩展接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span></span></div><div class="line">  <span class="keyword">extends</span> <span class="title">DangerousMonster</span>, <span class="title">Lethal</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常，我们只能对单独一个类应用 extends（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，extends可能引用多个基础接口。如上，接口的名字只是简单地使用逗号分隔。</p>
</li>
</ul>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><blockquote><p>将一个类定义置入另一个类定义中。这就叫作“内部类”.</p>
<footer><strong>think in java</strong></footer></blockquote>
<h5 id="典型例子1"><a href="#典型例子1" class="headerlink" title="典型例子1:"></a>典型例子1:</h5><p>  一个外部类拥有一个特殊的方法，它会返回指向一个内部类的句柄。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07.parcel2;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String label;</div><div class="line">        Destination(String whereTo) &#123;</div><div class="line">            label = whereTo;</div><div class="line">        &#125;</div><div class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</div><div class="line">        Contents c = cont();</div><div class="line">        Destination d = to(dest);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel2 p = <span class="keyword">new</span> Parcel2();</div><div class="line">        p.ship(<span class="string">"Tanzania"</span>);</div><div class="line">        Parcel2 q = <span class="keyword">new</span> Parcel2();</div><div class="line">        <span class="comment">// Defining handles to inner classes:</span></div><div class="line">        Parcel2.Contents c = q.cont();</div><div class="line">        Parcel2.Destination d = q.to(<span class="string">"Borneo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

若想在除外部类非static 方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为“外部类名.内部类名”，就象 main()中展示的那样
</code></pre><h5 id="内部类和上溯造型"><a href="#内部类和上溯造型" class="headerlink" title="内部类和上溯造型"></a>内部类和上溯造型</h5><p>  以下将展示通过内部类隐藏具体实施细节的例子</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07.parcel3;</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel3</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">extends</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String label;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</div><div class="line">            label = whereTo;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel3 p = <span class="keyword">new</span> Parcel3();</div><div class="line">        Contents c = p.cont();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">        <span class="comment">// Illegal -- can't access private class:</span></div><div class="line">        <span class="comment">//! Parcel3.PContents c = p.new PContents();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

&gt;&gt; *Contents 和Destination 代表可由客户程序员使用的接口（记住&lt;mark&gt;接口会将自己的所有成员都变成public属性&lt;/mark&gt;）。为方便起见，它们置于单独一个文件里，但原始的 Contents 和Destination 在它们自己的文件中是&lt;mark&gt;相互public&lt;/mark&gt; 的。*

客户程序员对这些成员的认识与访问将会受到限制。事实上，我们甚至&lt;mark&gt;不能下溯造型到一个 private内部类&lt;/mark&gt;（或者一个 protected 内部类，除非自己本身便是一个继承者），因为我们不能访问名字。

普通（非内部）类&lt;mark&gt;不可&lt;/mark&gt;设为private或 protected——只允许 public或者“友好的”。
</code></pre><h5 id="方法和作用域中的内部类p181"><a href="#方法和作用域中的内部类-P181" class="headerlink" title="方法和作用域中的内部类(P181)"></a>方法和作用域中的内部类<code>(P181)</code></h5><p>  我们在一个方法甚至一个任意的作用域内创建内部类。(1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。(2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。</p>
<p>  在下面这个例子里，将修改前面的代码，以便使用：</p>
<ol>
<li>在一个方法内定义的类</li>
<li>在方法的一个作用域内定义的类</li>
<li>一个匿名类，用于实现一个接口</li>
<li>一个匿名类，用于扩展拥有非默认构建器的一个类</li>
<li>一个匿名类，用于执行字段初始化</li>
<li><p>一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; i = x; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">            <span class="keyword">private</span> String label;</div><div class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</div><div class="line">                label = whereTo;</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel4 p = <span class="keyword">new</span> Parcel4();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//另外一个例子-------不同的作用域，和变量类似</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(b) &#123;</div><div class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123;</div><div class="line">                <span class="keyword">private</span> String id;</div><div class="line">                TrackingSlip(String s) &#123;</div><div class="line">                    id = s;</div><div class="line">                &#125;</div><div class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</div><div class="line">            &#125;</div><div class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</div><div class="line">            String s = ts.getSlip();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Can't use it here! Out of scope:</span></div><div class="line">        <span class="comment">//! TrackingSlip ts = new TrackingSlip("x");</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; internalTracking(<span class="keyword">true</span>); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel5 p = <span class="keyword">new</span> Parcel5();</div><div class="line">        p.track();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//另外一个例子-------返回匿名类，并实现接口</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">        &#125;; <span class="comment">// Semicolon required in this case</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel6 p = <span class="keyword">new</span> Parcel6();</div><div class="line">        Contents c = p.cont();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"><span class="comment">/*这种奇怪的语法要表达的意思是：“创建从 Contents 衍生出来的匿名类的一个对象”。</span></div><div class="line">由 new表达式返回的句柄会自动上溯造型成一个Contents 句柄。匿名内部类的语法其实要表达的是：</div><div class="line">class MyContents implements Contents &#123;</div><div class="line">    private int i = 11;</div><div class="line">    public int value() &#123; return i; &#125;</div><div class="line">&#125;</div><div class="line">return new MyContents();*/</div><div class="line"></div><div class="line"><span class="comment">//当继承的基础类含有带参数的构造器时-------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="comment">// Base constructor call:</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;; <span class="comment">// Semicolon required</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</div><div class="line">        Wrapping w = p.wrap(<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*这里的匿名内部类可以调用构造函数*/</span></div><div class="line"></div><div class="line"><span class="comment">//下面是初始化匿名内部类中的字段例子</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</div><div class="line">    <span class="comment">// Argument must be final to use inside</span></div><div class="line">    <span class="comment">// anonymous inner class:</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(<span class="keyword">final</span> String dest)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</div><div class="line">            <span class="keyword">private</span> String label = dest;                <span class="comment">//^_^</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel8 p = <span class="keyword">new</span> Parcel8();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：*/</span></div><div class="line"><span class="comment">/*若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是</span></div><div class="line">我们将dest()的自变量设为final 的原因。*/</div><div class="line"></div><div class="line"><span class="comment">//使用构造快来，来实现匿名内部类的成员初始化</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel9</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</div><div class="line">            <span class="comment">//-----------------------------------------------------</span></div><div class="line">            <span class="comment">// Instance initialization for each object: 这里使用实例初始化         </span></div><div class="line">            &#123;</div><div class="line">                cost = Math.round(price);</div><div class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</div><div class="line">                System.out.println(<span class="string">"Over budget!"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//-----------------------------------------------------</span></div><div class="line">            <span class="keyword">private</span> String label = dest;</div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel9 p = <span class="keyword">new</span> Parcel9();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>, <span class="number">101.395F</span>);</div><div class="line">        System.out.println(d.readLabel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*结果如下</span></div><div class="line">Over budget!</div><div class="line">Tanzania</div><div class="line"></div><div class="line">实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们**不能对实例初始化模块进行过载**处</div><div class="line">理，所以只能拥有这些构建器的其中一个。</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="内部类链接到外部类"><a href="#内部类链接到外部类" class="headerlink" title="内部类链接到外部类"></a>内部类链接到外部类</h5><p>  创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。如下代码：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object[] o;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        o = <span class="keyword">new</span> Object[size];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(next &lt; o.length) &#123;</div><div class="line">            o[next] = x;</div><div class="line">            next++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> i == o.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> o[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(i &lt; o.length) i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SSelector();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Sequence s = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">        s.add(Integer.toString(i));</div><div class="line"></div><div class="line">        Selector sl = s.getSelector();</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!sl.end()) &#123;</div><div class="line">            System.out.println((String)sl.current());</div><div class="line">            sl.next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="static内部类"><a href="#static内部类" class="headerlink" title="static内部类"></a>static内部类</h5><p>  使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：</p>
<ol>
<li>它的创建是不需要依赖于外围类的。</li>
<li><p>它不能使用任何外围类的非static成员变量和方法。</p>
<p>下面有个网上摘抄的demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String sex;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"chenssy"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">    *静态内部类</div><div class="line">    */</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;</div><div class="line">        <span class="comment">/* 在静态内部类中可以存在静态成员 */</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _name1 = <span class="string">"chenssy_static"</span>;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="comment">/* </span></div><div class="line">            * 静态内部类只能访问外围类的静态成员变量和方法</div><div class="line">            * 不能访问外围类的非静态成员变量和方法</div><div class="line">            */</div><div class="line">            System.out.println(<span class="string">"OutClass name :"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 非静态内部类</div><div class="line">    */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;</div><div class="line">        <span class="comment">/* 非静态内部类中不能存在静态成员 */</span></div><div class="line">        <span class="keyword">public</span> String _name2 = <span class="string">"chenssy_inner"</span>;</div><div class="line">        <span class="comment">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"OuterClass name："</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">    * <span class="doctag">@desc</span> 外围类方法</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">/* 外围类访问静态内部类：内部类. */</span></div><div class="line">        System.out.println(InnerClass1._name1);</div><div class="line">        <span class="comment">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span></div><div class="line">        <span class="keyword">new</span> InnerClass1().display();</div><div class="line">        </div><div class="line">        <span class="comment">/* 非静态内部的创建需要依赖于外围类 */</span></div><div class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().new InnerClass2();</div><div class="line">        <span class="comment">/* 方位非静态内部类的成员需要使用非静态内部类的实例 */</span></div><div class="line">        System.out.println(inner2._name2);</div><div class="line">        inner2.display();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</div><div class="line">        outer.display();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    ----------------</div><div class="line">    Output:</div><div class="line">    chenssy_static</div><div class="line">    OutClass name :chenssy</div><div class="line">    chenssy_inner</div><div class="line">    OuterClass name：chenssy</div></pre></td></tr></table></figure>
<p>通常，我们不在一个接口里设置任何代码，但 static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static 内部类只位于接口的命名空间内部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line">      <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">          <span class="keyword">int</span> i, j, k;</div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">          <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="引用外部类对象"><a href="#引用外部类对象" class="headerlink" title="引用外部类对象"></a>引用外部类对象</h5><p>  有些时候，我们想告诉其他某些对象创建它某个内部类的一个对象。为达到这个目的，必须在 new表达式中提供指向其他外部类对象的一个句柄，就象下面这样：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String label;</div><div class="line">        Destination(String whereTo) &#123;</div><div class="line">            label = whereTo;</div><div class="line">        &#125;</div><div class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel11 p = <span class="keyword">new</span> Parcel11();</div><div class="line">        <span class="comment">// Must use instance of outer class</span></div><div class="line">        <span class="comment">// to create an instances of the inner class:----------注意外部类的引用 p</span></div><div class="line">        Parcel11.Contents c = p.new Contents();</div><div class="line">        Parcel11.Destination d = p.new Destination(<span class="string">"Tanzania"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="从内部类继承"><a href="#从内部类继承" class="headerlink" title="从内部类继承"></a>从内部类继承</h5><p>  当继承内部类时，有一个很重要的问题，内部类必须要在外部类初始化，并且有一个对象句柄才能使用，所以在这里，继承内部类后的类，在实例化时，要使的他与所继承类的外部类有联系，通过下面代码展现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</div><div class="line">    <span class="comment">//! InheritInner() &#123;&#125; // Won't compile</span></div><div class="line">    InheritInner(WithInner wi) &#123;</div><div class="line">        wi.<span class="keyword">super</span>();                 <span class="comment">//super()调用</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</div><div class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi); <span class="comment">//建立联系</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="内部类继承覆盖"><a href="#内部类继承覆盖" class="headerlink" title="内部类继承覆盖"></a>内部类继承覆盖</h5><p>  继承时，内部类的覆盖要明确指明,如：<figure class="highlight plain"><figcaption><span>class Yolk extends Egg2.Yolk```,下面的书上的一个例子。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```java</div><div class="line">  class Egg2 &#123;</div><div class="line">      protected class Yolk &#123;</div><div class="line">          public Yolk() &#123;</div><div class="line">              System.out.println(&quot;Egg2.Yolk()&quot;);</div><div class="line">          &#125;</div><div class="line">          public void f() &#123;</div><div class="line">              System.out.println(&quot;Egg2.Yolk.f()&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private Yolk y = new Yolk();</div><div class="line"></div><div class="line">      public Egg2() &#123;</div><div class="line">          System.out.println(&quot;New Egg2()&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      public void insertYolk(Yolk yy) &#123; y = yy; &#125;</div><div class="line"></div><div class="line">      public void g() &#123; y.f(); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public class BigEgg2 extends Egg2 &#123;</div><div class="line">      public class Yolk extends Egg2.Yolk &#123;</div><div class="line">          public Yolk() &#123;</div><div class="line">              System.out.println(&quot;BigEgg2.Yolk()&quot;);</div><div class="line">          &#125;</div><div class="line">          public void f() &#123;</div><div class="line">              System.out.println(&quot;BigEgg2.Yolk.f()&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      public BigEgg2() &#123; insertYolk(new Yolk()); &#125;</div><div class="line"></div><div class="line">      public static void main(String[] args) &#123;</div><div class="line">          Egg2 e2 = new BigEgg2();</div><div class="line">          e2.g();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  方法 insertYolk()允许BigEgg2将它自己的某个 Yolk 对象上溯造型至 Egg2 的y 句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。<br>  输出结果如下：<br><br>  Egg2.Yolk()<br><br>  New Egg2()<br><br>  Egg2.Yolk()<br><br>  BigEgg2.Yolk()<br><br>  BigEgg2.Yolk.f()<br></p>
<h5 id="769-为什么要用内部类控制框架p192"><a href="#7-6-9-为什么要用内部类：控制框架（P192）" class="headerlink" title="7.6.9 为什么要用内部类：控制框架（P192）"></a>7.6.9 为什么要用内部类：控制框架（P192）</h5><pre><code>自己看代码研究（记得调试观察）
</code></pre><h4 id="构建器和多形性"><a href="#构建器和多形性" class="headerlink" title="构建器和多形性"></a>构建器和多形性</h4><h5 id="构建器的调用顺序"><a href="#构建器的调用顺序" class="headerlink" title="构建器的调用顺序"></a>构建器的调用顺序</h5><p>  基础类的构建器肯定在一个衍生类的构建器中调用，而且逐渐向上链接，原因在于：检查对象是否得到了正确的构建。一个衍生类只能访问它自己的成员，不能访问基础类的成员（这些成员通常都具有private 属性）。只有基础类的构建器在初始化自己的元素时才知道正确的方法以及拥有适当的权限。<br><br>  若我们没有明确指定对一个基础类构建器的调用，它就会“默默”地调用默认构建器。如果不存在默认构建器，编译器就会报告一个错误（若某个类没有构建器，编译器会自动组织一个默认构建器）。<br><br>  下面是个例子<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</div><div class="line">    Meal() &#123; System.out.println(<span class="string">"Meal()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</div><div class="line">    Bread() &#123; System.out.println(<span class="string">"Bread()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</div><div class="line">    Cheese() &#123; System.out.println(<span class="string">"Cheese()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</div><div class="line">    Lettuce() &#123; System.out.println(<span class="string">"Lettuce()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</div><div class="line">    Lunch() &#123; System.out.println(<span class="string">"Lunch()"</span>);&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</div><div class="line">    PortableLunch() &#123;</div><div class="line">        System.out.println(<span class="string">"PortableLunch()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</div><div class="line">    Bread b = <span class="keyword">new</span> Bread();</div><div class="line">    Cheese c = <span class="keyword">new</span> Cheese();</div><div class="line">    Lettuce l = <span class="keyword">new</span> Lettuce();</div><div class="line">    Sandwich() &#123;</div><div class="line">        System.out.println(<span class="string">"Sandwich()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Sandwich();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果如下：</span></div><div class="line"><span class="comment">//Meal()</span></div><div class="line"><span class="comment">//Lunch()</span></div><div class="line"><span class="comment">//PortableLunch()</span></div><div class="line"><span class="comment">//Bread()</span></div><div class="line"><span class="comment">//Cheese()</span></div><div class="line"><span class="comment">//Lettuce()</span></div><div class="line"><span class="comment">//Sandwich()</span></div></pre></td></tr></table></figure></p>
<ol>
<li>调用基础类构建器。这个步骤会不断重复下去，首先得到构建的是分级结构的根部，然后是下一个衍生类，等等。直到抵达最深一层的衍生类。</li>
<li>按声明顺序调用成员初始化模块。</li>
<li>调用衍生构建器的主体。</li>
</ol>
<h4 id="继承和-finalize"><a href="#继承和-finalize" class="headerlink" title="继承和 finalize()"></a>继承和 finalize()</h4><ol>
<li>通过合成，程序完结时，一定会调用finalize()释放。离衍生类最近的成员类先释放。</li>
<li><p>如果继承的父类，没有覆盖finalize()方法且没有调用super.finalize()，那衍生调用finalize后，父类不会在finalize。</p>
<p>例子在<mark>P199</mark></p>
</li>
</ol>
<h4 id="一个关于初始化需要注意的问题"><a href="#一个关于初始化需要注意的问题" class="headerlink" title="一个关于初始化需要注意的问题"></a>一个关于初始化需要注意的问题</h4><p>  先看代码:<br></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">    Glyph() &#123;</div><div class="line">        System.out.println(<span class="string">"Glyph() before draw()"</span>);</div><div class="line">        draw();</div><div class="line">        System.out.println(<span class="string">"Glyph() after draw()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> radius = <span class="number">1</span>;</div><div class="line"></div><div class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</div><div class="line">        radius = r;</div><div class="line">        System.out.println(<span class="string">"RoundGlyph.RoundGlyph(), radius = "</span> + radius);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"RoundGlyph.draw(), radius = "</span> + radius);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果如下：</div><div class="line">Glyph() <span class="function">before <span class="title">draw</span><span class="params">()</span></span></div><div class="line">RoundGlyph.<span class="title">draw</span><span class="params">()</span>, radius = <span class="number">0</span></div><div class="line">Glyph() <span class="function">after <span class="title">draw</span><span class="params">()</span></span></div><div class="line">RoundGlyph.<span class="title">RoundGlyph</span><span class="params">()</span>, radius = <span class="number">5</span></div></pre></td></tr></table></figure>
<ol>
<li>子类调用父类构造器时，因为子类重写了抽象类的方法，而那时子类的成员并没被初始化。说以父类构造器调用会出现意想不到的错误。</li>
<li>一般不要再构造器中调用方法来初始化类。</li>
<li>在构建器内唯一能够安全调用的是在基础类中具有final 属性的那些方法（也适用于<mark>private方法，它们自动具有final 属性</mark>）。这些方法不能被覆盖，所以不会出现上述潜在的问题。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 基础 </category>
            
            <category> 多形性 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础 类再生(java编程思想)]]></title>
      <url>http://mingcode.cn/2017/05/27/javaBase-%E7%B1%BB%E5%86%8D%E7%94%9F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<blockquote>
<h3 id="1-关于合成与继承"><a href="#1-关于合成与继承" class="headerlink" title="1 .关于合成与继承"></a>1 .关于合成与继承</h3></blockquote>
<ul>
<li><p>合成：合成只需在新类里简单地置入对象句柄即可，更加灵活，对象会被置null值，基础数据类型置0或者false。</p>
</li>
<li><p>继承：在新类后面使用关键字extends加上一个基础类，则可完成继承，新类可以继承基础类的所有非private变量和方法。</p>
<a id="more"></a>
</li>
<li><p>一般合成与继承两种技术结合起来使用</p>
</li>
<li><p>只有在清楚知道继承在所有方法中最有效的前提下，才可考虑继承。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。</p>
</li>
</ul>
<blockquote>
<h3 id="2-final关键字"><a href="#2-final关键字" class="headerlink" title="2 .final关键字"></a>2 .final关键字</h3></blockquote>
<h4 id="final数据"><a href="#final数据：" class="headerlink" title="final数据："></a>final数据：</h4><p>（1）编译期常数，它永远不会改变，对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型。无论static还是final字段，都只能存储一个数据，而且不得改变。（2）但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。</p>
<ul>
<li><ol>
<li>空白final：允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。</li>
</ol>
</li>
<li><ol>
<li>final自变量：允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> </span>&#123;</div><div class="line">    <span class="comment">//! g = new Gizmo(); // Illegal g is final</span></div><div class="line">    g.spin();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">without</span><span class="params">(Gizmo g)</span> </span>&#123;</div><div class="line">    g = <span class="keyword">new</span> Gizmo(); <span class="comment">// OK g not final</span></div><div class="line">    g.spin();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="final方法"><a href="#final方法：" class="headerlink" title="final方法："></a>final方法：</h4><p>第一个是为方法“上锁”，防止任何继承类改变它的本来含义。第二是为程序执行的效率<code>[p155]</code>类内所有 private 方法都自动成为 final 。</p>
<h4 id="final-类"><a href="#final-类：" class="headerlink" title="final 类："></a>final 类：</h4><p>整个类都是final（在它的定义前冠以 final 关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。</p>
<blockquote>
<h3 id="3-继承初始化"><a href="#3-继承初始化" class="headerlink" title="3 .继承初始化"></a>3 .继承初始化</h3><p>先看代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">9</span>;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    Insect() &#123;</div><div class="line">        prt(<span class="string">"i = "</span> + i + <span class="string">", j = "</span> + j);</div><div class="line">        j = <span class="number">39</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x1 = prt(<span class="string">"static Insect.x1 initialized"</span>);</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">        <span class="keyword">return</span> <span class="number">47</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insect</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = prt(<span class="string">"Beetle.k initialized"</span>);</div><div class="line">    Beetle() &#123;</div><div class="line">        prt(<span class="string">"k = "</span> + k);</div><div class="line">        prt(<span class="string">"j = "</span> + j);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x2 =prt(<span class="string">"static Beetle.x2 initialized"</span>);</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">        <span class="keyword">return</span> <span class="number">63</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        prt(<span class="string">"Beetle constructor"</span>);</div><div class="line">        Beetle b = <span class="keyword">new</span> Beetle();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在看结果</p>
<pre><code>static Insect.x initialized
static Beetle.x initialized
Beetle constructor
i = 9, j = 0
Beetle.k initialized
k = 63
j = 39
</code></pre><blockquote>
<blockquote>
<p>父类静态变量（静态代码块，静态成员变量）–&gt; 子类静态变量（静态代码块，静态成员变量）–&gt;main函数–&gt;父类成员变量–&gt;父类构造器–&gt;子类成员变量–&gt;子类构造器</p>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 基础 </category>
            
            <category> 类再生 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-工厂模式 GOF-Factory-Method]]></title>
      <url>http://mingcode.cn/2017/05/02/GOF-Factory-Method/</url>
      <content type="html"><![CDATA[<h1 id="工厂方法模式-factory-method"><a href="#工厂方法模式-（Factory-Method）" class="headerlink" title="工厂方法模式 （Factory Method）"></a>工厂方法模式 （Factory Method）</h1><blockquote><p>工厂方法模式的意义是定义一个创建产品对象的<code>工厂接口</code>，将实际创建工作<code>推迟到子类</code>当中。核心工厂类不再负责产品的创建，<a id="more"></a>这样核心类成为一个<code>抽象工厂</code>角色，仅负责具体工厂子类必须<code>实现</code>的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
<footer><strong>Java研究组织</strong><cite><a href="http://tech.it168.com/a2009/0223/266/000000266400.shtml" target="_blank" rel="external">Java设计模式之工厂方法模式</a></cite></footer></blockquote>
<h2 id="工厂方法模式分为三种"><a href="#工厂方法模式分为三种" class="headerlink" title="工厂方法模式分为三种"></a>工厂方法模式分为三种</h2><pre><code>1. 普通工厂模式
2. 多个工厂方法模式
3. 静态工厂方法模式
</code></pre><h1 id="一普通工厂模式"><a href="#一-普通工厂模式" class="headerlink" title="一,普通工厂模式:"></a>一,普通工厂模式:</h1><blockquote>
<p>建立一个工厂类，对实现了同一接口的一些类进行实例的创建。<br>设计参考下图：</p>
</blockquote>
<img src="http://opdy5wv5e.bkt.clouddn.com/GOF/1/GOF-1.PNG" width="450" height="450" title="图1-1 简单工厂模式UML设计图">
<ul>
<li><p>创建Sender接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分别实现两个接口的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"this is phonesender!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"this is messagesender!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后创建工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (<span class="string">"phone"</span>.equals(type)) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"msg"</span>.equals(type)) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"请输入正确的类型!"</span>);  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();  </div><div class="line">        Sender sender = factory.produce(<span class="string">"msg"</span>);  </div><div class="line">        sender.Send();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>输出结果：<code>this is messagesender!</code></p>
</blockquote>
</li>
</ul>
<h1 id="二多个工厂方法模式"><a href="#二，多个工厂方法模式" class="headerlink" title="二，多个工厂方法模式"></a>二，多个工厂方法模式</h1><blockquote>
<p>是对普通工厂方法模式的改进，普通工厂方法模式中，字符串传递容易出错，可以通过多个工厂方法创建对象。参考图如下：</p>
</blockquote>
<img src="http://opdy5wv5e.bkt.clouddn.com/GOF/1/GOF-2.PNG" width="450" height="450" title="图1-2 多工厂方法UML设计图">
<ul>
<li><p>修改简单工厂模式中的SendFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">producePhone</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneSender();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMessage</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageSender();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设计测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();  </div><div class="line">        Sender sender = factory.produceMessage();  </div><div class="line">        sender.Send();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试结果</p>
</li>
<li><blockquote>
<p>输出结果：<code>this is messagesender!</code></p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 工厂模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工厂模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[404]]></title>
      <url>http://mingcode.cn/2017/01/05//404/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://mingcode.cn/2017/01/05/hello-world/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><h1 id="上次服务器加wp的崩溃后现在终于又有了以后要写些东西了"><a href="#上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了" class="headerlink" title="上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了"></a>上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了</h1></blockquote>]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 默认 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
