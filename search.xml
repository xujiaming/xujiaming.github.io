<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础 多形性(java编程思想)]]></title>
    <url>%2F2017%2F06%2F13%2FjavaBase-%E5%A4%9A%E5%BD%A2%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多形性</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础 类再生(java编程思想)]]></title>
    <url>%2F2017%2F05%2F27%2FjavaBase-%E7%B1%BB%E5%86%8D%E7%94%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1 .关于合成与继承 合成：合成只需在新类里简单地置入对象句柄即可，更加灵活，对象会被置null值，基础数据类型置0或者false。 继承：在新类后面使用关键字extends加上一个基础类，则可完成继承，新类可以继承基础类的所有非private变量和方法。 一般合成与继承两种技术结合起来使用 只有在清楚知道继承在所有方法中最有效的前提下，才可考虑继承。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。 2 .final关键字 final数据：（1）编译期常数，它永远不会改变，对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型。无论static还是final字段，都只能存储一个数据，而且不得改变。（2）但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。 空白final：允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。 final自变量：允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。如下： 12345678void with(final Gizmo g) &#123; //! g = new Gizmo(); // Illegal g is final g.spin();&#125;void without(Gizmo g) &#123; g = new Gizmo(); // OK g not final g.spin();&#125; final方法：第一个是为方法“上锁”，防止任何继承类改变它的本来含义。第二是为程序执行的效率[p155]类内所有 private 方法都自动成为 final 。 final 类：整个类都是final（在它的定义前冠以 final 关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。 3 .继承初始化先看代码 1234567891011121314151617181920212223242526272829class Insect &#123; int i = 9; int j; Insect() &#123; prt("i = " + i + ", j = " + j); j = 39; &#125; static int x1 = prt("static Insect.x1 initialized"); static int prt(String s) &#123; System.out.println(s); return 47; &#125;&#125;public class Beetle extends Insect &#123; int k = prt("Beetle.k initialized"); Beetle() &#123; prt("k = " + k); prt("j = " + j); &#125; static int x2 =prt("static Beetle.x2 initialized"); static int prt(String s) &#123; System.out.println(s); return 63; &#125; public static void main(String[] args) &#123; prt("Beetle constructor"); Beetle b = new Beetle(); &#125;&#125; 在看结果 static Insect.x initialized static Beetle.x initialized Beetle constructor i = 9, j = 0 Beetle.k initialized k = 63 j = 39 父类静态变量（静态代码块，静态成员变量）–&gt; 子类静态变量（静态代码块，静态成员变量）–&gt;父类成员变量–&gt;子类成员变量–&gt;main函数–&gt;父类构造器–&gt;子类构造器]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>类再生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式 GOF-Factory-Method]]></title>
    <url>%2F2017%2F05%2F02%2FGOF-Factory-Method%2F</url>
    <content type="text"><![CDATA[工厂方法模式 （Factory Method）工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 Java研究组织Java设计模式之工厂方法模式 工厂方法模式分为三种1. 普通工厂模式 2. 多个工厂方法模式 3. 静态工厂方法模式 一,普通工厂模式: 建立一个工厂类，对实现了同一接口的一些类进行实例的创建。设计参考下图： 创建Sender接口 123public interface Sender &#123; public void Send(); &#125; 分别实现两个接口的类 123456 public class PhoneSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is phonesender!"); &#125; &#125; 123456 public class MessageSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is messagesender!"); &#125; &#125; 然后创建工厂类 123456789101112public class SendFactory &#123; public Sender produce(String type) &#123; if ("phone".equals(type)) &#123; return new MailSender(); &#125; else if ("msg".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("请输入正确的类型!"); return null; &#125; &#125; &#125; 创建测试方法 1234567 public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce("msg"); sender.Send(); &#125; &#125; 输出结果：this is messagesender! 二，多个工厂方法模式 是对普通工厂方法模式的改进，普通工厂方法模式中，字符串传递容易出错，可以通过多个工厂方法创建对象。参考图如下： 修改简单工厂模式中的SendFactory 12345678public class SendFactory &#123; public Sender producePhone()&#123; return new PhoneSender(); &#125; public Sender produceMessage()&#123; return new MessageSender(); &#125; &#125; 设计测试类 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMessage(); sender.Send(); &#125; &#125; 测试结果 输出结果：this is messagesender!]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404]]></title>
    <url>%2F2017%2F01%2F05%2F%2F404%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
</search>