<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础 数组—集合(java编程思想)]]></title>
    <url>%2F2017%2F08%2F25%2FjavaBase-%E6%95%B0%E7%BB%84_%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[数组 定义和初始化 1Gerbil[] arr = new Gerbil[10]; 123 Gerbil[] arr2 = new Gerbil[]&#123; new Gerbil(1),new Gerbil(2)&#125;; 123 Gerbil[] arr3 = &#123; new Gerbil(1),new Gerbil(2)&#125;; 集合在jdk1.1和jdk1.2早期版中提供的基础版本有Java 提供了四种类型的“集合类”：Vector（矢量）、BitSet（位集）、Stack（堆栈）以及Hashtable（散列表）。 Vector单纯的一个容器类似现在的ArrayList 常用方法 Object elementAt(int postion)取得指定位置的元素 Enumeration elements() 获得对序列的一个“枚举” add(); get(int pos); Stack 实现了一个 LIFO（先入先出）序列 push() 压入 pop() 弹出 empty() 判空 Hashtable 是一种“关联数组”，允许我们将任何对象关联起来，从 Dictionary 继承。 put(Object key, Object value) 放入 remove(Object Key) 移除 get(Object key) 获得与某个键对应的值 keys() 产生对键的一个枚举（Enumeration） elements() 产生对所有值的一个枚举 isEmpty() 判断是否包含了元素枚举器 Enumeration hasMoreElements() nextElement()反复器 迭代器 Iterator 新集合 Collection 常用方法 boolean add(Object) ＊保证集合内包含了自变量。如果它没有添加自变量，就返回 false（假）boolean addAll(Collection) ＊添加自变量内的所有元素。如果没有添加元素，则返回 true（真）void clear() ＊删除集合内的所有元素boolean contains(Object) 若集合包含自变量，就返回“真”boolean containsAll(Collection) 若集合包含了自变量内的所有元素，就返回“真”boolean isEmpty() 若集合内没有元素，就返回“真”Iterator iterator() 返回一个反复器，以用它遍历集合的各元素boolean remove(Object) ＊如自变量在集合里，就删除那个元素的一个实例。如果已进行了删除，就返回“真”boolean removeAll(Collection) ＊删除自变量里的所有元素。如果已进行了任何删除，就返回“真”boolean retainAll(Collection) ＊只保留包含在一个自变量里的元素（一个理论的“交集”）。如果已进行了任何改变，就返回“真”int size() 返回集合内的元素数量Object[] toArray() 返回包含了集合内所有元素的一个数组 List 常用实现 List（接口） 顺序是 List 最重要的特性；它可保证元素按照规定的顺序排列。 ArrayList 由一个数组后推得到的 List。作为一个常规用途的对象容器使用，用于替换原先的Vector。允许我们快速访问元素，但在从列表中部插入和删除元素时，速度却嫌稍慢。一般只应该用ListIterator对一个ArrayList进行向前和向后遍历，不要用它删除和插入元素 LinkedList 提供优化的顺序访问性能，同时可以高效率地在列表中部进行插入和删除操作。但在进行随机访问时，速度却相当慢，此时应换用 ArrayList。也提供了addFirst()，addLast()，getFirst()，getLast()，removeFirst()以及removeLast()，以便将其作为一个规格、队列以及一个双向队列使用. Set Set拥有与 Collection完全相同的接口,没有什么额外的功能. 添加到 Set的每个元素都必须是独一无二的；否则Set就不会添加重复的元素。 添加到 Set里对象必须定义equals()，从而建立对象的唯一性。 Set不能保证自己可按任何特定的顺序维持自己的元素 HashSet 用于存非常小的以外的所有Set。对象也必须定义 hashCode() ArraySet 由一个数组后推得到的 Set。面向非常小的Set设计，特别是那些需要频繁创建和删除的。对于小Set，与HashSet 相比，ArraySet 创建和反复所需付出的代价都要小得多。但随着 Set的增大，它的性能也会大打折扣。不需要HashCode() TreeSet 由一个“红黑树”后推得到的顺序 Set。这样一来，我们就可以从一个Set 里提到一个顺序集合 Map HashMap 基于一个散列表实现（用它代替Hashtable）。针对“键－值”对的插入和检索，这种形式具有最稳定的性能。 ArrayMap 由一个 ArrayList后推得到的Map。对反复的顺序提供了精确的控制。面向非常小的 Map设计，特别是那些需要经常创建和删除的。对于非常小的Map，创建和反复所付出的代价要比 HashMap低得多。但在Map变大以后，性能也会相应地大幅度降低 TreeMap 在一个“红－黑”树的基础上实现。查看键或者“键－值”对时，它们会按固定的顺序排列（取决于Comparable 或Comparator，稍后即会讲到）。TreeMap最大的好处就是我们得到的是已排好序的结果。TreeMap是含有 subMap()方法的唯一一种Map，利用它可以返回树的一部分 Arrays Arrays.sort(array[]); //排序 Arrays.binarySearch(array[], array[pos]); //折半检索 Arrays.toString(aList)。//输出List 对于基础数据类型binarySearch可以直接使用，若是对象，sort()和binarySearch()方法使用时，对象必须实现接口Comparable，或者在binarySearch传入第三个参数，一个实现Comparator接口的类。 若在执行一次binarySearch()之前不调用 sort()，便会发生不可预测的行为，其中甚至包括无限循环。 Collections 拥有与 Arrays 中差不多的签名 sort(List)用于对一个实现了 Comparable的对象列表进行排序。 binarySearch(List,Object)用于查找列表中的某个对象。 sort(List,Comparator)利用一个“比较器”对一个列表进行排序。 binarySearch(List,Object,Comparator)则用于查找那个列表中的一个对象。 enumeration(Collection) 为自变量产生原始风格的Enumeration（枚举） max(Collection)，min(Collection) 在自变量中用集合内对象的自然比较方法产生最大或最小元素 max(Collection,Comparator)，min(Collection,Comparator) 在集合内用比较器产生最大或最小元素 nCopies(int n, Object o) 返回长度为 n 的一个不可变列表，它的所有句柄均指向o 使 Collection或 Map不可修改 创建 Collection或 Map的一个“只读”版本显得更有利一些 Collections.unmodifiableCollection(c); Collections.unmodifiableList(a); Collections.unmodifiableSet(s); Collections.unmodifiableMap(m); Collection 或Map 的同步 Collection c = Collections.synchronizedCollection(new ArrayList()); List list = Collections.synchronizedList(new ArrayList()); Set s = Collections.synchronizedSet(new HashSet()); Map m = Collections.synchronizedMap(new HashMap());]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>数组 集合</category>
      </categories>
      <tags>
        <tag>java 数组 集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring学习 环境搭建练习]]></title>
    <url>%2F2017%2F08%2F03%2FjavaEE-SpringStudy-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"></content>
      <categories>
        <category>javaee</category>
        <category>spring</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javaee spring 学习 搭建 maven oracle mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring学习 概述 (spring in action 4th)]]></title>
    <url>%2F2017%2F07%2F14%2FjavaEE-SpringStudy-spring%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[介绍Spring是一个开源框架，最早由Rod Johnson创建，并在《Expert One-on-One：J2EE Design andDevelopment》地址 这本著作中进行了介绍。Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）。 为了降低Java开发的复杂性，Spring采取了以下4种关键策略： 基于POJO的轻量级和最小侵入性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板式代码 Spring竭力避免因自身的API而弄乱你的应用代码。Spring不会强迫你实现Spring规范的接口或继承Spring规范的类，相反，在基于Spring构建的应用中，它的类通常没有任何痕迹表明你使用了Spring。 控制反转(Inversion of Control)控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。 IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖查找（Dependency Lookup）：容器提供回调接口和上下文环境给组件。依赖注入（Dependency Injection）：组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。 依赖注入依赖如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。123456public class Human &#123; Father father; public Human() &#123; father = new Father(); &#125;&#125; 如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码； 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中； 如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。 依赖注入上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式 123456public class Human &#123; Father father; public Human(Father father) &#123; this.father = father; &#125;&#125; 上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。 现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：(1). 解耦，将依赖之间解耦。(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。 有接口注入（Interface Injection），设值注入（Setter Injection）和构造子注入（Constructor Injection）三种方式 在spring中可以通过xml文件，注解和java文件进行实现。 依赖注入优点：查找定位操作与应用代码完全无关。不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。 应用切面动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-orientedprogramming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。 Spring容器（container）P38在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。如图1.4所示，Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是new到finalize()）。 Spring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。bean工厂（由org.springframework. beans. factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。应用上下文（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。——–主要使用应用上下文。 使用应用上下文Spring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的。AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载Spring Web应用上下文。ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml"); ApplicationContext context = new ClassPathXmlApplicationContext("knight.xml"); ``` 使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：FileSystemXmlApplicationContext在指定的文件系统路径下查找knight.xml文件；而ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件）下查找knight.xml文件。如果你想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext：```java ApplicationContext context = new AnnotationConfigApplicationContext(com.springinaction. knights.config.KnightConfig.class);``` ### bean的生命周期1. Spring对bean进行实例化；2. Spring将值和bean的引用注入到bean对应的属性中；3. 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；4. 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；5. 果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；6. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；7. 如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；8. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；9. 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；10. 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。写个例子：有三个java文件OneBean.java,PostService.java,Test.java,还有个上下文依赖关系文件applicationContext.xml**applicationContext.xml**```xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="oneBean" class="com.bean.life.OneBean" init-method="myInit" destroy-method="myDestroy" &gt; &lt;property name="beanName1" value="555"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="postService" class="com.bean.life.PostService"&gt;&lt;/bean&gt; &lt;/beans&gt; OneBean.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.bean.life;import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.BeanFactoryAware;import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;//如果设置了init-method="myInit" destroy-method="myDestroy" //两个方法（推荐使用）就不需要实现InitializingBean,DisposableBeanpublic class OneBean implements BeanNameAware ,BeanFactoryAware, ApplicationContextAware,InitializingBean,DisposableBean &#123; private String beanName1 = null; public String getBeanName1() &#123;return beanName1;&#125; public void setBeanName1(String beanName1) &#123;this.beanName1 = beanName1;&#125; public String OutName() &#123;return beanName1;&#125; public OneBean() &#123; System.out.println("（1）我是OneBean的构造函数"); System.out.println(beanName1); &#125; @Override public void setBeanName(String name) &#123; // TODO 自动生成的方法存根 System.out.println("（2）将被设置的bean名称！"+name); &#125; @Override public void setBeanFactory(BeanFactory arg0) throws BeansException &#123; // TODO 自动生成的方法存根 System.out.println("-------------------------------------------------"); System.out.println("（3）OneBean实现BeanFactoryAware后得到FactoryBean" + "(在OneBean.java输出)："+arg0); System.out.println(" FactoryBean得到的OneBean与this本身相等：" +(arg0.getBean("oneBean") == this)); System.out.println(" "+beanName1); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; // TODO 自动生成的方法存根 System.out.println("------------------------------------------------"); System.out.println("（4）OneBean实现ApplicationContextAware后得到ApplicationContext" +" (在OneBean.java输出)："+applicationContext); System.out.println(" ApplicationContext得到的OneBean与this本身相等：" +(applicationContext.getBean("oneBean") == this)); System.out.println(" "+beanName1); System.out.println("---------------------------------------------------"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; // TODO 自动生成的方法存根 System.out.println("（6）运行afterPropertiesSet()方法"); &#125; public void myInit() &#123;System.out.println("（7）执行自己定义初始化的方法myInit()（需要在xml里面配置）");&#125; public void myDestroy() &#123;System.out.println("（10）执行自己定义Destroy()方法（需要在xml里面配置）");&#125; @Override public void destroy() throws Exception &#123; // TODO 自动生成的方法存根 System.out.println("（9）执行destroy()方法"); &#125;&#125; PostService.java12345678910111213141516171819202122232425package com.bean.life;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class PostService implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; // TODO 自动生成的方法存根 System.out.println("（5）---这是init之前执行的方法postProcessBeforeInitialization---"); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; // TODO 自动生成的方法存根 System.out.println("（8）----这是init之后执行的方法postProcessAfterInitialization----"); return bean; &#125;&#125; Test.java123456789101112131415161718package com.bean.life;import org.springframework.context.ApplicationContext;import org.springframework.context.support.AbstractApplicationContext;import com.service.ApplicationContextUtil;public class Test &#123; public static void main(String[] args) &#123; System.out.println("main---初始化之前！"); ApplicationContext applicationContext = ApplicationContextUtil.getAc(); System.out.println("main---得到applicationContext后！"); OneBean oneBean = (OneBean) applicationContext.getBean("oneBean"); System.out.println("OneBean中的OutName方法调用："+oneBean.OutName()); AbstractApplicationContext aac =(AbstractApplicationContext) applicationContext; aac.close(); &#125;&#125; 执行结果123456789101112131415161718192021222324252627main---初始化之前！七月 14, 2017 4:19:48 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy七月 14, 2017 4:19:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions信息: Loading XML bean definitions from class path resource [applicationContext.xml]（1）我是OneBean的构造函数null（2）将被设置的bean名称！oneBean-------------------------------------------------------------------------（3）OneBean实现BeanFactoryAware后得到FactoryBean(在OneBean.java输出)：org.springframework.beans.factory.support.DefaultListableBeanFactory@b44eaa0: defining beans [oneBean,postService]; root of factory hierarchy FactoryBean得到的OneBean与this本身相等：true 555---------------------------------------------------------------------------（4）OneBean实现ApplicationContextAware后得到ApplicationContext(在OneBean.java输出)：org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy ApplicationContext得到的OneBean与this本身相等：true 555---------------------------------------------------------------------------（5）---这是init之前执行的方法postProcessBeforeInitialization---（6）运行afterPropertiesSet()方法（7）执行自己定义初始化的方法myInit()（需要在xml里面配置）（8）----这是init之后执行的方法postProcessAfterInitialization----main---得到applicationContext后！OneBean中的OutName方法调用：555七月 14, 2017 4:19:48 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy（9）执行destroy()方法（10）执行自己定义Destroy()方法（需要在xml里面配置） Spring模块Spring框架由6个定义良好的模块分类组成123456789101112131415161718192021222324252627282930Data access &amp; integration |----JDBC |----OXM |----Messaging |----Transaction |----ORM |----JMSWeb and remoting \\Web与远程调用 |----Web |----Web servlet |----Web portlet |----WebSocketAspect-oriented programming \\Spring的AOP模块 |----AOP |----AspectsInstrumentation |----Instrument Tomcat |----InstrumentCore Spring container \\Spring核心容器 |----Beans |----Core |----Context |----Expression |----Context supportTesting |----Test 核心容器（Core Spring container ） spring-core和spring-beans：提供框架的基础部分，包括控制反转和依赖注入的特性，BeanFactory是用工厂模式来实现的，使我们不用自己去创建单例对象，并将依赖的配置和设计与业务逻辑分开来。 spring-context模块是建立在前两者之上的，通过它可以使用框架风格（framework-style）的方法来访问对象，类似于JNDI服务注册。该模块集成了bean模块，并加入了国际化、事件传播、资源加载、透明化生成上下文，还支持Java EE特性如EJB、 JMX 和 basic remoting。context模块的关键是ApplicationContext接口。spring-context-support支持集成第三方库，如缓存、邮件、调度、模板引擎等。 spring-expression: 提供了强大的EL（ expression language）在运行状态查询和操纵对象，它支持属性的赋值，通过setter和getter方法设置和获取属性值、方法调用、访问数组 集合、逻辑和数学操纵、变量命名、通过IoC容器检索对象。 AOP和插装(Aspect-oriented programming ) spring-aop :模块提供了面向切面编程的实现，使我们可以定义方法拦截器和切点来使得分离功能独立的业务。使用基于源的元数据功能，我们还可以将行为信息集成到代码中，这和.NET的属性很相似。 spring-aspects :模块支持Spring 框架整合AspectJ. spring-instrument 在特定容器中实现类插装和类加载器的实施 。 spring-instrument-tomcat包含Tomcat的Spring插装代理。 消息(Messaging) spring-messaging 模块包含从 Message，MessageChannel，MessageHandler 等其他基于消息的基础应用中得到的抽象。该模块还包含一系列的注解来讲消息映射到方法上，和SpringMVC注解类似 。 数据访问控制(Data access &amp; integration) spring-jdbc提供JDBC抽象层 ，使我们从繁重的JDBC编程中解脱出来，并且不再需要为解析不同的数据库的异常而烦恼。 spring-tx支持对所有POJO和实现了特定接口的类进行 编程式和申明式事务（ programmatic and declarative transaction ）管理。 spring-orm整合了流行的ORM（object-relational mapping ）应用程序接口，包括JPA、JDO和Hibernate。使用该模块我们可以任意使用这些ORM框架和Spring的其他功能（如上面的申明式事务管理进行组合。 spring-oxm为OXM（Object/XML mapping） 的实现提供抽象层，如 JAXB、Castor、XMLBeans、JiBX 和XStream。 spring-jms 是Java消息服务(Java Messaging Service)，包含产生和接受消息 。Spring Framework 4.1将它并入在spring-messaging 模块。 Web(Web and remoting) spring-web 包含基本的面向网络的集成特性，如文件分部上传，使用Servet监听器和面向网络的应用上下文初始化IoC容器。他还包括 HTTP 客户端和网络相关的 Spring远程支持。 spring-webmvc 也被成为 Web-Servlet 模块，包含Spring的模型-视图-控制器（model-view-controller，MVC) 和 REST Web Services。 Spring MVC 框架是得实体模型代码和网络表单清楚地离开来，还可以轻松集成Spring框架的其他特性。 spring-webmvc-portlet 也被称为 Web-Portlet 模块，在Portlet 容器中实现MVC，并且能使用spring-webmvc 模块的功能。 测试(Testing) spring-test 模块支持单元测试 JUnit 、集成测试 TestNG和独立代码测试 mock objects。它支持加载和缓存 Spring ApplicationContexts。]]></content>
      <categories>
        <category>javaee</category>
        <category>spring</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javaee spring 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[培训笔记 银海 oracle]]></title>
    <url>%2F2017%2F07%2F14%2F%E9%93%B6%E6%B5%B7%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0-oracle%2F</url>
    <content type="text"><![CDATA[（exp/imp）数据导入导出 是在cmd命令下，而不是sqlplus中。 数据导出(exp) 完全导出 导出到D:\zjgl.dmp system/root@ORCL file=d:\orcl.dmp full=y```123456 将数据库orcl完全导出，full=y 表示全库导出，缺省情况下full=no，这时只会将该用户下的对象导出。system/root一定要有dba权限2. 将数据库orcl中zjgl用户与scott用户的表导出 ``` exp system/root@ORCL file=d:\zjgl_scott.dmp owner=(zjgl,scott) full方式可以备份所有用户的数据库对象，包括表空间、用户信息等，owner=XX只能备份指定用户的对象，其他用户下的就不备份了，EXP中full=y和owner=XX是不能同时使用的。 将数据库orcl中的表t_users导出 system/root@ORCL file= d:\t_users.dmp tables=(t_users)```1234567891011121314151617 tables=xx 表示备份相关表，不能同时和owner、full使用。....更多操作百度。#### 数据导入(imp)1. 将D:\test.dmp 中的数据导入 test数据库中。 imp system/root@test file=D:\test.dmp导数据得时候，有可能报错。为什么？有以下主要的原因： A. 导入的对象（表，视图，方法等）原本不属于当前连接的用户的&lt;br&gt; B. 导入的对象在该数据库的指定用户下已经存在&lt;br&gt; C. 导入的对象的原本用户不在这个数据库里&lt;br&gt;解决 2. 所有对象全部导入到指定的账户下： ``` imp system/root@ORCL file=d:\test.dmp fromuser=zjgl touser=zjgl_new 其中fromuser=zjgl为.dmp文件里的对象的原先的owner, touser=zjgl_new为作为导入的对象的新的Owner. 忽略/插入数据： system/root@ORCL file=d:\test.dmp ignore=y```12345其中ignore=y告诉imp.exe把数据直接插入到相应对象（并且如果导入的对象里面有其他的对象，如约束，索引等，会在数据插入后被创建）。4. 将d:\test.dmp中的表test1 导入 ```imp system/root@ORCL file=d:\test.dmp tables=(test1) (expdp/impdp)数据泵导入导出使用expdp和impdp时应该注重的事项： exp和imp是客户端工具程序，它们既可以在客户端使用，也可以在服务端使用。 expdp和impdp是服务端的工具程序，他们只能在oracle服务端使用，不能在客户端使用。 imp只适用于exp导出的文件，不适用于expdp导出文件；impdp只适用于expdp导出的文件，而不适用于exp导出文件。 对于10g以上的服务器，使用exp通常不能导出0行数据的空表，而此时必须使用expdp导出。 一 sys/root@orcl as sysdba``` 登录dba用户1234567 二 创建操作目录 ```create directory caozuo as &apos;R:\daochu&apos;;```&lt;br&gt; 三 查询是否存在 ```select * from dba_directories;```&lt;br&gt; 四 退出 sqlplus#### 导出1. 导出用户```expdp scott/tiger@orcl schemas=scott dumpfile=scott.dmp directory=caozuo logfile=expdb.log; 导出日志必须有logfile=expdb.log，主要schemas=scott 导出表 scott/tiger@orcl tables=emp,dept dumpfile=scott_emp_dept.dmp directory=caozuo logfile=expdb2.log;``1234 主要**tables=emp,dept**3. 按查询条件导```expdp scott/tiger@orcl directory=caozuo dumpfile=expdp_where.dmp tables=emp query=&apos;where deptno=20&apos;; query=’where deptno=20’ 按表空间导 scott/tiger@orcl directory=caozuo dumpfile=tablespace.dmp tablespaces=temp,example```;1234**tablespaces=temp,example**5. 导整个数据库```expdp scott/tiger@orcl directory=caozuo dumpfile=full.dmp full=y; full=y 导入 导入用户（从用户scott导入到用户scott） scott/tiger@orcl directory=caozuo dumpfile=expdp.dmp ```**schemas=scott**;1234567891011121314151617181920212223242. 导入表（从scott用户中把表dept和emp导入到system用户中）```impdp system/manager@orcl directory=caozuo dumpfile=expdp.dmp`` **tables=scott.dept,scott.emp remap_schema=scott:system**;3. 导入表空间```impdp system/manager@orcl directory=caozuo dumpfile=tablespace.dmp ```**tablespaces=example**;4. 导入数据库```impdb system/manager@orcl directory=caozuo dumpfile=full.dmp``` **full=y**;5. 追加数据```impdp system/manager@orcl directory=caozuo dumpfile=expdp.dmp``` **schemas=system table_exists_action**### 函数#### 单行函数```coalesce(arg,arg1,...)``` 从左侧开始，第一个不为空的值&lt;br&gt;```nullif(A,B)```A和B相等返回NULL,否则返回A&lt;br&gt;```rtrim()```将右边的空格压缩类似ltrim()&lt;br&gt;```select NEXT_DAY(sysdate,&apos;星期五&apos;) from dual;``` &lt;br&gt;```trunc(sysdate,&apos;hh24&apos;) 11g新函数分组函数 可使用over()函数；示范：select ename,deptno,avg(sal) over(partition by deptno) avgsal from emp;Pivot 和 unpivot语法 `http://blog.csdn.net/tianlesoftware/article/details/7060306]]></content>
      <categories>
        <category>培训</category>
        <category>银海</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>培训笔记 oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础 多形性[多态](java编程思想)]]></title>
    <url>%2F2017%2F06%2F13%2FjavaBase-%E5%A4%9A%E5%BD%A2%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[多形性（多态）：“对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。)”“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成长”。 ——–think in java 具体知识点上溯造型以一个简单的例子说明，类图如下：在上面的例子中，automobile继承自car，因为继承树的画法是基础类位于最上方，所以称之为上溯造型。我们可以知道automobile是car的子类。所以可以这样定义 1car sub = new automobile(); 通过基础类的句柄可以调用子类的方法。 以下有一个利用上溯造型的例子 1234567891011121314151617181920212223242526272829303132package c07;class Note &#123;private int value;private Note(int val) &#123; value = val; &#125;public static final Note middleC = new Note(0), cSharp = new Note(1), cFlat = new Note(2);&#125; // Etc.class Instrument &#123; public void play(Note n) &#123; System.out.println("Instrument.play()"); &#125;&#125;// Wind objects are instruments// because they have the same interface:class Wind extends Instrument &#123;// Redefine interface method: public void play(Note n) &#123; System.out.println("Wind.play()"); &#125;&#125;public class Music &#123; public static void tune(Instrument i) &#123; // ... i.play(Note.middleC); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); tune(flute); // Upcasting &#125;&#125; 有一个问题： 编译器怎样才能知道 Instrument句柄指向的是一个 Wind，而不是一个Brass 或Stringed 呢？ 这里就涉及到了方法调用的绑定了，java主要是使用“后期绑定”，后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。Java 中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成final。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。为什么要把一个方法声明成final 呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final 方法调用生成效率更高的代码。 覆盖与过载“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。过载时返回值和参数数量，参数类型顺序不同，覆盖是返回值和参数完全一致。 抽象类和方法 包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。 如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为基础类中的所有抽象方法提供方法定义。如果不这样做（完全可以选择不做），则衍生类也会是抽象的，而且编译器会强迫我们用abstract关键字标志那个类的“抽象”本质。 即使不包括任何abstract 方法，亦可将一个类声明成“抽象类”。如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。 以下用个图来说明 上面就是一个继承关系,Wind属于Instrument，Wind实现了play方法。Instrument只是一个种类的抽象，定义了部分方法，没有实现，它不能具体实例化，但可以像下面的形式使用。 12Instrument wind = new Wind();wind.play(1); 接口“interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static 和final。接口只提供一种形式，并不提供实施的细节。 think in java 可将一个接口中的方法声明明确定义为“public”。但即便不明确定义，它们也会默认为 public。所以在实现一个接口的时候，来自接口的方法必须定义成public。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java 编译器不允许我们那样做。 创建一个新类时，可以上溯到它所实现的接口上面。 关于&quot;多继承&quot;(P175) 如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于 implements关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面有个例子： 12345678910111213141516171819202122232425import java.util.*;interface CanFight &#123;void fight();&#125;interface CanSwim &#123;void swim();&#125;interface CanFly &#123;void fly();&#125;class ActionCharacter &#123;public void fight() &#123;&#125;&#125;class Hero extends ActionCharacterimplements CanFight, CanSwim, CanFly &#123; public void swim() &#123;&#125; public void fly() &#123;&#125;&#125;public class Adventure &#123; static void t(CanFight x) &#123; x.fight(); &#125; static void u(CanSwim x) &#123; x.swim(); &#125; static void v(CanFly x) &#123; x.fly(); &#125; static void w(ActionCharacter x) &#123; x.fight(); &#125; public static void main(String[] args) &#123; Hero i = new Hero(); t(i); // Treat it as a CanFight u(i); // Treat it as a CanSwim v(i); // Treat it as a CanFly w(i); // Treat it as an ActionCharacter &#125;&#125; 当继承和接口实现中出现相同的方法标签fight()(在ActionCharacter类和CanFight接口中)，接口的可以从继承中实现。 上述例子已向我们揭示了接口最关键的作用，也是使用接口最重要的一个原因：能上溯造型至多个基础类。 这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？ 若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类 通过继承扩展接口 1234interface Vampire extends DangerousMonster, Lethal &#123; void drinkBlood();&#125; 通常，我们只能对单独一个类应用 extends（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，extends可能引用多个基础接口。如上，接口的名字只是简单地使用逗号分隔。 内部类将一个类定义置入另一个类定义中。这就叫作“内部类”. think in java 典型例子1: 一个外部类拥有一个特殊的方法，它会返回指向一个内部类的句柄。 1234567891011121314151617181920212223242526272829303132package c07.parcel2;public class Parcel2 &#123; class Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; public Destination to(String s) &#123; return new Destination(s); &#125; public Contents cont() &#123; return new Contents(); &#125; public void ship(String dest) &#123; Contents c = cont(); Destination d = to(dest); &#125; public static void main(String[] args) &#123; Parcel2 p = new Parcel2(); p.ship("Tanzania"); Parcel2 q = new Parcel2(); // Defining handles to inner classes: Parcel2.Contents c = q.cont(); Parcel2.Destination d = q.to("Borneo"); &#125;&#125; 若想在除外部类非static 方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为“外部类名.内部类名”，就象 main()中展示的那样 内部类和上溯造型 以下将展示通过内部类隐藏具体实施细节的例子 1234567891011121314151617181920212223242526272829303132333435363738package c07.parcel3;abstract class Contents &#123; abstract public int value();&#125;interface Destination &#123; String readLabel();&#125;public class Parcel3 &#123; private class PContents extends Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; protected class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; public Destination dest(String s) &#123; return new PDestination(s); &#125; public Contents cont() &#123; return new PContents(); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Parcel3 p = new Parcel3(); Contents c = p.cont(); Destination d = p.dest("Tanzania"); // Illegal -- can't access private class: //! Parcel3.PContents c = p.new PContents(); &#125;&#125; &gt;&gt; *Contents 和Destination 代表可由客户程序员使用的接口（记住&lt;mark&gt;接口会将自己的所有成员都变成public属性&lt;/mark&gt;）。为方便起见，它们置于单独一个文件里，但原始的 Contents 和Destination 在它们自己的文件中是&lt;mark&gt;相互public&lt;/mark&gt; 的。* 客户程序员对这些成员的认识与访问将会受到限制。事实上，我们甚至&lt;mark&gt;不能下溯造型到一个 private内部类&lt;/mark&gt;（或者一个 protected 内部类，除非自己本身便是一个继承者），因为我们不能访问名字。 普通（非内部）类&lt;mark&gt;不可&lt;/mark&gt;设为private或 protected——只允许 public或者“友好的”。 方法和作用域中的内部类(P181) 我们在一个方法甚至一个任意的作用域内创建内部类。(1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。(2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。 在下面这个例子里，将修改前面的代码，以便使用： 在一个方法内定义的类 在方法的一个作用域内定义的类 一个匿名类，用于实现一个接口 一个匿名类，用于扩展拥有非默认构建器的一个类 一个匿名类，用于执行字段初始化 一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package c07.innerscopes;interface Destination &#123; String readLabel();&#125;interface Contents &#123; int value();&#125;public class Wrapping &#123; private int i; public Wrapping(int x) &#123; i = x; &#125; public int value() &#123; return i; &#125;&#125;public class Parcel4 &#123; public Destination dest(String s) &#123; class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; return new PDestination(s); &#125; public static void main(String[] args) &#123; Parcel4 p = new Parcel4(); Destination d = p.dest("Tanzania"); &#125;&#125;//另外一个例子-------不同的作用域，和变量类似public class Parcel5 &#123; private void internalTracking(boolean b) &#123; if(b) &#123; class TrackingSlip &#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip() &#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip("slip"); String s = ts.getSlip(); &#125; // Can't use it here! Out of scope: //! TrackingSlip ts = new TrackingSlip("x"); &#125; public void track() &#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); p.track(); &#125;&#125; //另外一个例子-------返回匿名类，并实现接口public class Parcel6 &#123; public Contents cont() &#123; return new Contents() &#123; private int i = 11; public int value() &#123; return i; &#125; &#125;; // Semicolon required in this case &#125; public static void main(String[] args) &#123; Parcel6 p = new Parcel6(); Contents c = p.cont(); &#125;&#125; /*这种奇怪的语法要表达的意思是：“创建从 Contents 衍生出来的匿名类的一个对象”。由 new表达式返回的句柄会自动上溯造型成一个Contents 句柄。匿名内部类的语法其实要表达的是：class MyContents implements Contents &#123; private int i = 11; public int value() &#123; return i; &#125;&#125;return new MyContents();*///当继承的基础类含有带参数的构造器时-------------------------public class Parcel7 &#123; public Wrapping wrap(int x) &#123; // Base constructor call: return new Wrapping(x) &#123; public int value() &#123; return super.value() * 47; &#125; &#125;; // Semicolon required &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Wrapping w = p.wrap(10); &#125;&#125;/*这里的匿名内部类可以调用构造函数*///下面是初始化匿名内部类中的字段例子public class Parcel8 &#123; // Argument must be final to use inside // anonymous inner class: public Destination dest(final String dest) &#123; return new Destination() &#123; private String label = dest; //^_^ public String readLabel() &#123; return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel8 p = new Parcel8(); Destination d = p.dest("Tanzania"); &#125;&#125;/*由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：*//*若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是我们将dest()的自变量设为final 的原因。*///使用构造快来，来实现匿名内部类的成员初始化public class Parcel9 &#123; public Destination dest(final String dest, final float price) &#123; return new Destination() &#123; private int cost; //----------------------------------------------------- // Instance initialization for each object: 这里使用实例初始化 &#123; cost = Math.round(price); if(cost &gt; 100) System.out.println("Over budget!"); &#125; //----------------------------------------------------- private String label = dest; public String readLabel() &#123; return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel9 p = new Parcel9(); Destination d = p.dest("Tanzania", 101.395F); System.out.println(d.readLabel()); &#125;&#125;/*结果如下Over budget!Tanzania实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们**不能对实例初始化模块进行过载**处理，所以只能拥有这些构建器的其中一个。*/ 内部类链接到外部类 创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Selector &#123; boolean end(); Object current(); void next();&#125;public class Sequence &#123; private Object[] o; private int next = 0; public Sequence(int size) &#123; o = new Object[size]; &#125; public void add(Object x) &#123; if(next &lt; o.length) &#123; o[next] = x; next++; &#125; &#125; private class SSelector implements Selector &#123; int i = 0; public boolean end() &#123; return i == o.length; &#125; public Object current() &#123; return o[i]; &#125; public void next() &#123; if(i &lt; o.length) i++; &#125; &#125; public Selector getSelector() &#123; return new SSelector(); &#125; public static void main(String[] args) &#123; Sequence s = new Sequence(10); for(int i = 0; i &lt; 10; i++) s.add(Integer.toString(i)); Selector sl = s.getSelector(); while(!sl.end()) &#123; System.out.println((String)sl.current()); sl.next(); &#125; &#125;&#125; static内部类 使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖于外围类的。 它不能使用任何外围类的非static成员变量和方法。 下面有个网上摘抄的demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class OuterClass &#123; private String sex; public static String name = "chenssy"; /** *静态内部类 */ static class InnerClass1&#123; /* 在静态内部类中可以存在静态成员 */ public static String _name1 = "chenssy_static"; public void display()&#123; /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println("OutClass name :" + name); &#125; &#125; /** * 非静态内部类 */ class InnerClass2&#123; /* 非静态内部类中不能存在静态成员 */ public String _name2 = "chenssy_inner"; /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display()&#123; System.out.println("OuterClass name：" + name); &#125; &#125; /** * @desc 外围类方法 */ public void display()&#123; /* 外围类访问静态内部类：内部类. */ System.out.println(InnerClass1._name1); /* 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 */ OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); /* 方位非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.display(); &#125;&#125; ---------------- Output: chenssy_static OutClass name :chenssy chenssy_inner OuterClass name：chenssy 通常，我们不在一个接口里设置任何代码，但 static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static 内部类只位于接口的命名空间内部： 1234567interface IInterface &#123; static class Inner &#123; int i, j, k; public Inner() &#123;&#125; void f() &#123;&#125; &#125; &#125; 引用外部类对象 有些时候，我们想告诉其他某些对象创建它某个内部类的一个对象。为达到这个目的，必须在 new表达式中提供指向其他外部类对象的一个句柄，就象下面这样： 12345678910111213141516171819202122public class Parcel11 &#123; class Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; public static void main(String[] args) &#123; Parcel11 p = new Parcel11(); // Must use instance of outer class // to create an instances of the inner class:----------注意外部类的引用 p Parcel11.Contents c = p.new Contents(); Parcel11.Destination d = p.new Destination("Tanzania"); &#125;&#125; 从内部类继承 当继承内部类时，有一个很重要的问题，内部类必须要在外部类初始化，并且有一个对象句柄才能使用，所以在这里，继承内部类后的类，在实例化时，要使的他与所继承类的外部类有联系，通过下面代码展现 12345678910111213class WithInner &#123; class Inner &#123;&#125;&#125;public class InheritInner extends WithInner.Inner &#123; //! InheritInner() &#123;&#125; // Won't compile InheritInner(WithInner wi) &#123; wi.super(); //super()调用 &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); //建立联系 &#125;&#125; 内部类继承覆盖 继承时，内部类的覆盖要明确指明,如：class Yolk extends Egg2.Yolk```,下面的书上的一个例子。12345678910111213141516171819202122232425262728293031323334353637383940```java class Egg2 &#123; protected class Yolk &#123; public Yolk() &#123; System.out.println(&quot;Egg2.Yolk()&quot;); &#125; public void f() &#123; System.out.println(&quot;Egg2.Yolk.f()&quot;); &#125; &#125; private Yolk y = new Yolk(); public Egg2() &#123; System.out.println(&quot;New Egg2()&quot;); &#125; public void insertYolk(Yolk yy) &#123; y = yy; &#125; public void g() &#123; y.f(); &#125; &#125; public class BigEgg2 extends Egg2 &#123; public class Yolk extends Egg2.Yolk &#123; public Yolk() &#123; System.out.println(&quot;BigEgg2.Yolk()&quot;); &#125; public void f() &#123; System.out.println(&quot;BigEgg2.Yolk.f()&quot;); &#125; &#125; public BigEgg2() &#123; insertYolk(new Yolk()); &#125; public static void main(String[] args) &#123; Egg2 e2 = new BigEgg2(); e2.g(); &#125; &#125; 方法 insertYolk()允许BigEgg2将它自己的某个 Yolk 对象上溯造型至 Egg2 的y 句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。 输出结果如下： Egg2.Yolk() New Egg2() Egg2.Yolk() BigEgg2.Yolk() BigEgg2.Yolk.f() 7.6.9 为什么要用内部类：控制框架（P192）自己看代码研究（记得调试观察） 构建器和多形性构建器的调用顺序 基础类的构建器肯定在一个衍生类的构建器中调用，而且逐渐向上链接，原因在于：检查对象是否得到了正确的构建。一个衍生类只能访问它自己的成员，不能访问基础类的成员（这些成员通常都具有private 属性）。只有基础类的构建器在初始化自己的元素时才知道正确的方法以及拥有适当的权限。 若我们没有明确指定对一个基础类构建器的调用，它就会“默默”地调用默认构建器。如果不存在默认构建器，编译器就会报告一个错误（若某个类没有构建器，编译器会自动组织一个默认构建器）。 下面是个例子 123456789101112131415161718192021222324252627282930313233343536373839class Meal &#123; Meal() &#123; System.out.println("Meal()"); &#125;&#125;class Bread &#123; Bread() &#123; System.out.println("Bread()"); &#125;&#125;class Cheese &#123; Cheese() &#123; System.out.println("Cheese()"); &#125;&#125;class Lettuce &#123; Lettuce() &#123; System.out.println("Lettuce()"); &#125;&#125;class Lunch extends Meal &#123; Lunch() &#123; System.out.println("Lunch()");&#125;&#125;class PortableLunch extends Lunch &#123; PortableLunch() &#123; System.out.println("PortableLunch()"); &#125;&#125;class Sandwich extends PortableLunch &#123; Bread b = new Bread(); Cheese c = new Cheese(); Lettuce l = new Lettuce(); Sandwich() &#123; System.out.println("Sandwich()"); &#125; public static void main(String[] args) &#123; new Sandwich(); &#125;&#125;//结果如下：//Meal()//Lunch()//PortableLunch()//Bread()//Cheese()//Lettuce()//Sandwich() 调用基础类构建器。这个步骤会不断重复下去，首先得到构建的是分级结构的根部，然后是下一个衍生类，等等。直到抵达最深一层的衍生类。 按声明顺序调用成员初始化模块。 调用衍生构建器的主体。 继承和 finalize() 通过合成，程序完结时，一定会调用finalize()释放。离衍生类最近的成员类先释放。 如果继承的父类，没有覆盖finalize()方法且没有调用super.finalize()，那衍生调用finalize后，父类不会在finalize。 例子在P199 一个关于初始化需要注意的问题 先看代码: 123456789101112131415161718192021222324252627282930313233abstract class Glyph &#123; abstract void draw(); Glyph() &#123; System.out.println("Glyph() before draw()"); draw(); System.out.println("Glyph() after draw()"); &#125;&#125;class RoundGlyph extends Glyph &#123; int radius = 1; RoundGlyph(int r) &#123; radius = r; System.out.println("RoundGlyph.RoundGlyph(), radius = " + radius); &#125; void draw() &#123; System.out.println("RoundGlyph.draw(), radius = " + radius); &#125;&#125;public class PolyConstructors &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125;结果如下：Glyph() before draw()RoundGlyph.draw(), radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(), radius = 5 子类调用父类构造器时，因为子类重写了抽象类的方法，而那时子类的成员并没被初始化。说以父类构造器调用会出现意想不到的错误。 一般不要再构造器中调用方法来初始化类。 在构建器内唯一能够安全调用的是在基础类中具有final 属性的那些方法（也适用于private方法，它们自动具有final 属性）。这些方法不能被覆盖，所以不会出现上述潜在的问题。]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多形性</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础 类再生(java编程思想)]]></title>
    <url>%2F2017%2F05%2F27%2FjavaBase-%E7%B1%BB%E5%86%8D%E7%94%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1 .关于合成与继承 合成：合成只需在新类里简单地置入对象句柄即可，更加灵活，对象会被置null值，基础数据类型置0或者false。 继承：在新类后面使用关键字extends加上一个基础类，则可完成继承，新类可以继承基础类的所有非private变量和方法。 一般合成与继承两种技术结合起来使用 只有在清楚知道继承在所有方法中最有效的前提下，才可考虑继承。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。 2 .final关键字 final数据：（1）编译期常数，它永远不会改变，对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型。无论static还是final字段，都只能存储一个数据，而且不得改变。（2）但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。 空白final：允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。 final自变量：允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。如下： 12345678void with(final Gizmo g) &#123; //! g = new Gizmo(); // Illegal g is final g.spin();&#125;void without(Gizmo g) &#123; g = new Gizmo(); // OK g not final g.spin();&#125; final方法：第一个是为方法“上锁”，防止任何继承类改变它的本来含义。第二是为程序执行的效率[p155]类内所有 private 方法都自动成为 final 。 final 类：整个类都是final（在它的定义前冠以 final 关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。 3 .继承初始化先看代码 1234567891011121314151617181920212223242526272829class Insect &#123; int i = 9; int j; Insect() &#123; prt("i = " + i + ", j = " + j); j = 39; &#125; static int x1 = prt("static Insect.x1 initialized"); static int prt(String s) &#123; System.out.println(s); return 47; &#125;&#125;public class Beetle extends Insect &#123; int k = prt("Beetle.k initialized"); Beetle() &#123; prt("k = " + k); prt("j = " + j); &#125; static int x2 =prt("static Beetle.x2 initialized"); static int prt(String s) &#123; System.out.println(s); return 63; &#125; public static void main(String[] args) &#123; prt("Beetle constructor"); Beetle b = new Beetle(); &#125;&#125; 在看结果 static Insect.x initialized static Beetle.x initialized Beetle constructor i = 9, j = 0 Beetle.k initialized k = 63 j = 39 父类静态变量（静态代码块，静态成员变量）–&gt; 子类静态变量（静态代码块，静态成员变量）–&gt;main函数–&gt;父类成员变量–&gt;父类构造器–&gt;子类成员变量–&gt;子类构造器]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>类再生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式 GOF-Factory-Method]]></title>
    <url>%2F2017%2F05%2F02%2FGOF-Factory-Method%2F</url>
    <content type="text"><![CDATA[工厂方法模式 （Factory Method）工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 Java研究组织Java设计模式之工厂方法模式 工厂方法模式分为三种1. 普通工厂模式 2. 多个工厂方法模式 3. 静态工厂方法模式 一,普通工厂模式: 建立一个工厂类，对实现了同一接口的一些类进行实例的创建。设计参考下图： 创建Sender接口 123public interface Sender &#123; public void Send(); &#125; 分别实现两个接口的类 123456 public class PhoneSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is phonesender!"); &#125; &#125; 123456 public class MessageSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is messagesender!"); &#125; &#125; 然后创建工厂类 123456789101112public class SendFactory &#123; public Sender produce(String type) &#123; if ("phone".equals(type)) &#123; return new MailSender(); &#125; else if ("msg".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("请输入正确的类型!"); return null; &#125; &#125; &#125; 创建测试方法 1234567 public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce("msg"); sender.Send(); &#125; &#125; 输出结果：this is messagesender! 二，多个工厂方法模式 是对普通工厂方法模式的改进，普通工厂方法模式中，字符串传递容易出错，可以通过多个工厂方法创建对象。参考图如下： 修改简单工厂模式中的SendFactory 12345678public class SendFactory &#123; public Sender producePhone()&#123; return new PhoneSender(); &#125; public Sender produceMessage()&#123; return new MessageSender(); &#125; &#125; 设计测试类 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMessage(); sender.Send(); &#125; &#125; 测试结果 输出结果：this is messagesender!]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404]]></title>
    <url>%2F2017%2F01%2F05%2F%2F404%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
</search>