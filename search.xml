<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础 多形性[多态](java编程思想)]]></title>
    <url>%2F2017%2F06%2F13%2FjavaBase-%E5%A4%9A%E5%BD%A2%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[多形性（多态）：“对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。)”“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成长”。 ——–think in java 具体知识点上溯造型以一个简单的例子说明，类图如下：在上面的例子中，automobile继承自car，因为继承树的画法是基础类位于最上方，所以称之为上溯造型。我们可以知道automobile是car的子类。所以可以这样定义 1car sub = new automobile(); 通过基础类的句柄可以调用子类的方法。 以下有一个利用上溯造型的例子 1234567891011121314151617181920212223242526272829303132package c07;class Note &#123;private int value;private Note(int val) &#123; value = val; &#125;public static final Note middleC = new Note(0), cSharp = new Note(1), cFlat = new Note(2);&#125; // Etc.class Instrument &#123; public void play(Note n) &#123; System.out.println("Instrument.play()"); &#125;&#125;// Wind objects are instruments// because they have the same interface:class Wind extends Instrument &#123;// Redefine interface method: public void play(Note n) &#123; System.out.println("Wind.play()"); &#125;&#125;public class Music &#123; public static void tune(Instrument i) &#123; // ... i.play(Note.middleC); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); tune(flute); // Upcasting &#125;&#125; 有一个问题： 编译器怎样才能知道 Instrument句柄指向的是一个 Wind，而不是一个Brass 或Stringed 呢？ 这里就涉及到了方法调用的绑定了，java主要是使用“后期绑定”，后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。Java 中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成final。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。为什么要把一个方法声明成final 呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final 方法调用生成效率更高的代码。 覆盖与过载“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。过载时返回值和参数数量，参数类型顺序不同，覆盖是返回值和参数完全一致。 抽象类和方法 包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。 如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为基础类中的所有抽象方法提供方法定义。如果不这样做（完全可以选择不做），则衍生类也会是抽象的，而且编译器会强迫我们用abstract关键字标志那个类的“抽象”本质。 即使不包括任何abstract 方法，亦可将一个类声明成“抽象类”。如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。 以下用个图来说明 上面就是一个继承关系,Wind属于Instrument，Wind实现了play方法。Instrument只是一个种类的抽象，定义了部分方法，没有实现，它不能具体实例化，但可以像下面的形式使用。 12Instrument wind = new Wind();wind.play(1);]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多形性</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础 类再生(java编程思想)]]></title>
    <url>%2F2017%2F05%2F27%2FjavaBase-%E7%B1%BB%E5%86%8D%E7%94%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1 .关于合成与继承 合成：合成只需在新类里简单地置入对象句柄即可，更加灵活，对象会被置null值，基础数据类型置0或者false。 继承：在新类后面使用关键字extends加上一个基础类，则可完成继承，新类可以继承基础类的所有非private变量和方法。 一般合成与继承两种技术结合起来使用 只有在清楚知道继承在所有方法中最有效的前提下，才可考虑继承。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。 2 .final关键字 final数据：（1）编译期常数，它永远不会改变，对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型。无论static还是final字段，都只能存储一个数据，而且不得改变。（2）但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。 空白final：允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。 final自变量：允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。如下： 12345678void with(final Gizmo g) &#123; //! g = new Gizmo(); // Illegal g is final g.spin();&#125;void without(Gizmo g) &#123; g = new Gizmo(); // OK g not final g.spin();&#125; final方法：第一个是为方法“上锁”，防止任何继承类改变它的本来含义。第二是为程序执行的效率[p155]类内所有 private 方法都自动成为 final 。 final 类：整个类都是final（在它的定义前冠以 final 关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。 3 .继承初始化先看代码 1234567891011121314151617181920212223242526272829class Insect &#123; int i = 9; int j; Insect() &#123; prt("i = " + i + ", j = " + j); j = 39; &#125; static int x1 = prt("static Insect.x1 initialized"); static int prt(String s) &#123; System.out.println(s); return 47; &#125;&#125;public class Beetle extends Insect &#123; int k = prt("Beetle.k initialized"); Beetle() &#123; prt("k = " + k); prt("j = " + j); &#125; static int x2 =prt("static Beetle.x2 initialized"); static int prt(String s) &#123; System.out.println(s); return 63; &#125; public static void main(String[] args) &#123; prt("Beetle constructor"); Beetle b = new Beetle(); &#125;&#125; 在看结果 static Insect.x initialized static Beetle.x initialized Beetle constructor i = 9, j = 0 Beetle.k initialized k = 63 j = 39 父类静态变量（静态代码块，静态成员变量）–&gt; 子类静态变量（静态代码块，静态成员变量）–&gt;父类成员变量–&gt;子类成员变量–&gt;main函数–&gt;父类构造器–&gt;子类构造器]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>类再生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式 GOF-Factory-Method]]></title>
    <url>%2F2017%2F05%2F02%2FGOF-Factory-Method%2F</url>
    <content type="text"><![CDATA[工厂方法模式 （Factory Method）工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 Java研究组织Java设计模式之工厂方法模式 工厂方法模式分为三种1. 普通工厂模式 2. 多个工厂方法模式 3. 静态工厂方法模式 一,普通工厂模式: 建立一个工厂类，对实现了同一接口的一些类进行实例的创建。设计参考下图： 创建Sender接口 123public interface Sender &#123; public void Send(); &#125; 分别实现两个接口的类 123456 public class PhoneSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is phonesender!"); &#125; &#125; 123456 public class MessageSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is messagesender!"); &#125; &#125; 然后创建工厂类 123456789101112public class SendFactory &#123; public Sender produce(String type) &#123; if ("phone".equals(type)) &#123; return new MailSender(); &#125; else if ("msg".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("请输入正确的类型!"); return null; &#125; &#125; &#125; 创建测试方法 1234567 public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce("msg"); sender.Send(); &#125; &#125; 输出结果：this is messagesender! 二，多个工厂方法模式 是对普通工厂方法模式的改进，普通工厂方法模式中，字符串传递容易出错，可以通过多个工厂方法创建对象。参考图如下： 修改简单工厂模式中的SendFactory 12345678public class SendFactory &#123; public Sender producePhone()&#123; return new PhoneSender(); &#125; public Sender produceMessage()&#123; return new MessageSender(); &#125; &#125; 设计测试类 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMessage(); sender.Send(); &#125; &#125; 测试结果 输出结果：this is messagesender!]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404]]></title>
    <url>%2F2017%2F01%2F05%2F%2F404%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
</search>