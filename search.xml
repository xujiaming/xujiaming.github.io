<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[spring学习 环境搭建练习]]></title>
      <url>http://mingcode.cn/2017/08/03/javaEE-SpringStudy-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%BB%83%E4%B9%A0/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> javaee </category>
            
            <category> spring </category>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaee spring 学习 搭建 maven oracle mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[培训笔记 银海 oracle]]></title>
      <url>http://mingcode.cn/2017/07/14/%E9%93%B6%E6%B5%B7%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0-oracle/</url>
      <content type="html"><![CDATA[<h3 id="expimp数据导入导出"><a href="#（exp-imp）数据导入导出" class="headerlink" title="（exp/imp）数据导入导出"></a>（exp/imp）数据导入导出</h3><p> 是在cmd命令下，而不是sqlplus中。</p>
<h4 id="数据导出exp"><a href="#数据导出-exp" class="headerlink" title="数据导出(exp)"></a>数据导出(exp)</h4><ol>
<li><p>完全导出 导出到D:\zjgl.dmp </p>
<figure class="highlight plain"><figcaption><span>system/root@ORCL file=d:\orcl.dmp full=y```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    将数据库orcl完全导出，full=y 表示全库导出，缺省情况下full=no，这时只会将该用户下的对象导出。system/root一定要有dba权限</div><div class="line"></div><div class="line">2. 将数据库orcl中zjgl用户与scott用户的表导出</div><div class="line"></div><div class="line">    ``` exp system/root@ORCL file=d:\zjgl_scott.dmp owner=(zjgl,scott)</div></pre></td></tr></table></figure>
<p> full方式可以备份所有用户的数据库对象，包括表空间、用户信息等，owner=XX只能备份指定用户的对象，其他用户下的就不备份了，EXP中full=y和owner=XX是不能同时使用的。</p>
</li>
<li><p>将数据库orcl中的表t_users导出</p>
<figure class="highlight plain"><figcaption><span>system/root@ORCL file= d:\t_users.dmp tables=(t_users)```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    tables=xx 表示备份相关表，不能同时和owner、full使用。....更多操作百度。</div><div class="line"></div><div class="line">#### 数据导入(imp)</div><div class="line">&lt;!--more--&gt;</div><div class="line"></div><div class="line">1. 将D:\test.dmp 中的数据导入 test数据库中。</div><div class="line">    imp system/root@test file=D:\test.dmp</div><div class="line">导数据得时候，有可能报错。为什么？有以下主要的原因：</div><div class="line"></div><div class="line">   A. 导入的对象（表，视图，方法等）原本不属于当前连接的用户的&lt;br&gt;</div><div class="line">   B. 导入的对象在该数据库的指定用户下已经存在&lt;br&gt;</div><div class="line">   C. 导入的对象的原本用户不在这个数据库里&lt;br&gt;</div><div class="line">解决 </div><div class="line"></div><div class="line">2. 所有对象全部导入到指定的账户下：</div><div class="line">    ``` imp system/root@ORCL file=d:\test.dmp fromuser=zjgl touser=zjgl_new</div></pre></td></tr></table></figure>
<p> 其中fromuser=zjgl为.dmp文件里的对象的原先的owner, touser=zjgl_new为作为导入的对象的新的Owner.</p>
</li>
<li><p>忽略/插入数据：</p>
 <figure class="highlight plain"><figcaption><span>system/root@ORCL file=d:\test.dmp ignore=y```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其中ignore=y告诉imp.exe把数据直接插入到相应对象（并且如果导入的对象里面有其他的对象，如约束，索引等，会在数据插入后被创建）。</div><div class="line"></div><div class="line">4. 将d:\test.dmp中的表test1 导入</div><div class="line">    ```imp system/root@ORCL file=d:\test.dmp tables=(test1)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="expdpimpdp数据泵导入导出"><a href="#expdp-impdp-数据泵导入导出" class="headerlink" title="(expdp/impdp)数据泵导入导出"></a>(expdp/impdp)数据泵导入导出</h3><p>使用expdp和impdp时应该注重的事项：</p>
<ol>
<li>exp和imp是客户端工具程序，它们既可以在客户端使用，也可以在服务端使用。</li>
<li>expdp和impdp是服务端的工具程序，他们只能在oracle服务端使用，不能在客户端使用。</li>
<li>imp只适用于exp导出的文件，不适用于expdp导出文件；impdp只适用于expdp导出的文件，而不适用于exp导出文件。</li>
<li><p>对于10g以上的服务器，使用exp通常不能导出0行数据的空表，而此时必须使用expdp导出。</p>
<p> 一 <figure class="highlight plain"><figcaption><span>sys/root@orcl as sysdba``` 登录dba用户<br></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    二 创建操作目录 ```create directory caozuo as &apos;R:\daochu&apos;;```&lt;br&gt;</div><div class="line">    三 查询是否存在 ```select * from dba_directories;```&lt;br&gt;</div><div class="line">    四 退出 sqlplus</div><div class="line"></div><div class="line">#### 导出</div><div class="line">1. 导出用户</div><div class="line">```expdp scott/tiger@orcl schemas=scott dumpfile=scott.dmp directory=caozuo logfile=expdb.log;</div></pre></td></tr></table></figure></p>
<p>  导出日志必须有<strong>logfile=expdb.log</strong>，主要<strong>schemas=scott</strong></p>
</li>
<li><p>导出表</p>
<figure class="highlight plain"><figcaption><span>scott/tiger@orcl tables=emp,dept dumpfile=scott_emp_dept.dmp directory=caozuo logfile=expdb2.log;``</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     主要**tables=emp,dept**</div><div class="line"></div><div class="line">3. 按查询条件导```expdp scott/tiger@orcl directory=caozuo dumpfile=expdp_where.dmp tables=emp query=&apos;where deptno=20&apos;;</div></pre></td></tr></table></figure>
<p>  <strong>query=’where deptno=20’</strong></p>
</li>
<li>按表空间导</li>
</ol>
<figure class="highlight plain"><figcaption><span>scott/tiger@orcl directory=caozuo dumpfile=tablespace.dmp tablespaces=temp,example```;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">**tablespaces=temp,example**</div><div class="line"></div><div class="line">5. 导整个数据库</div><div class="line">```expdp scott/tiger@orcl directory=caozuo dumpfile=full.dmp full=y;</div></pre></td></tr></table></figure>
<p><strong>full=y</strong></p>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><ol>
<li>导入用户（从用户scott导入到用户scott）</li>
</ol>
<figure class="highlight plain"><figcaption><span>scott/tiger@orcl directory=caozuo dumpfile=expdp.dmp ```**schemas=scott**;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 导入表（从scott用户中把表dept和emp导入到system用户中）</div><div class="line"></div><div class="line">```impdp system/manager@orcl directory=caozuo dumpfile=expdp.dmp`` </div><div class="line">    **tables=scott.dept,scott.emp remap_schema=scott:system**;</div><div class="line"></div><div class="line">3. 导入表空间</div><div class="line"></div><div class="line">```impdp system/manager@orcl directory=caozuo dumpfile=tablespace.dmp ```**tablespaces=example**;</div><div class="line"></div><div class="line">4. 导入数据库</div><div class="line"></div><div class="line">```impdb system/manager@orcl directory=caozuo dumpfile=full.dmp``` **full=y**;</div><div class="line"></div><div class="line">5. 追加数据</div><div class="line">```impdp system/manager@orcl directory=caozuo dumpfile=expdp.dmp``` **schemas=system table_exists_action**</div><div class="line"></div><div class="line">### 函数</div><div class="line">#### 单行函数</div><div class="line">```coalesce(arg,arg1,...)``` 从左侧开始，第一个不为空的值&lt;br&gt;</div><div class="line">```nullif(A,B)```A和B相等返回NULL,否则返回A&lt;br&gt;</div><div class="line">```rtrim()```将右边的空格压缩类似ltrim()&lt;br&gt;</div><div class="line">```select NEXT_DAY(sysdate,&apos;星期五&apos;) from dual;``` &lt;br&gt;</div><div class="line">```trunc(sysdate,&apos;hh24&apos;)</div></pre></td></tr></table></figure>
<h4 id="11g新函数"><a href="#11g新函数" class="headerlink" title="11g新函数"></a>11g新函数</h4><p>分组函数 可使用over()函数；示范：<code>select ename,deptno,avg(sal) over(partition by deptno) avgsal from emp;</code><br>Pivot 和 unpivot语法     <code>`http://blog.csdn.net/tianlesoftware/article/details/7060306</code></p>
]]></content>
      
        <categories>
            
            <category> 培训 </category>
            
            <category> 银海 </category>
            
            <category> oracle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 培训笔记 oracle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring学习 概述 (spring in action 4th)]]></title>
      <url>http://mingcode.cn/2017/07/14/javaEE-SpringStudy-spring%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring是一个开源框架，最早由Rod Johnson创建，并在《Expert One-on-One：J2EE Design andDevelopment》<br><a href="http://amzn.com/076454385" target="_blank" rel="external">地址</a>  这本著作中进行了介绍。Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖<br>于它的两个核心特性，也就是<strong>依赖注入</strong>（dependency injection，<strong>DI</strong>）和<strong>面向切面编程</strong>（aspect-oriented programming，<strong>AOP</strong>）。</p>
<p></p><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p>
<ol>
<li>基于POJO的轻量级和最小侵入性编程；</li>
<li>通过依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>通过切面和模板减少样板式代码</li>
</ol>
<p>Spring竭力避免因自身的API而弄乱你的应用代码。Spring不会强迫你实现Spring规范的接口<br>或继承Spring规范的类，相反，在基于Spring构建的应用中，它的类通常没有任何痕迹表明<br>你使用了Spring。<br><a id="more"></a></p>
<h3 id="控制反转inversion-of-control"><a href="#控制反转-Inversion-of-Control" class="headerlink" title="控制反转(Inversion of Control)"></a>控制反转(Inversion of Control)</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p>IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：<1>依赖查找（Dependency Lookup）：容器提供回调接口和上下文环境给组件。<2>依赖注入（Dependency Injection）：组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</2></1></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    Father father;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;</div><div class="line">        father = <span class="keyword">new</span> Father();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码；</li>
<li>如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；</li>
<li>如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。</li>
</ol>
<h4 id="依赖注入"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    Father father;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(Father father)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.father = father;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种<strong>非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入</strong>。</p>
<p>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：(1). 解耦，将依赖之间解耦。(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</p>
<p>有接口注入（Interface Injection），设值注入（Setter Injection）和构造子注入（Constructor Injection）三种方式</p>
<p>在spring中可以通过xml文件，注解和java文件进行实现。</p>
<p>依赖注入优点：<1>查找定位操作与应用代码完全无关。<2>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。<3>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</3></2></1></p>
<h3 id="应用切面"><a href="#应用切面" class="headerlink" title="应用切面"></a>应用切面</h3><p>动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-orientedprogramming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</p>
<h3 id="spring容器containerp38"><a href="#Spring容器（container）P38" class="headerlink" title="Spring容器（container）P38"></a>Spring容器（container）<em>P38</em></h3><p>在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。如图1.4所示，Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是new到finalize()）。</p>
<p>Spring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。<strong>bean工厂（由org.springframework. beans. factory.eanFactory接口定义）是最简单的容器</strong>，提供基本的DI支持。<strong>应用上下文（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建</strong>，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。——–主要使用应用上下文。</p>
<h4 id="使用应用上下文"><a href="#使用应用上下文" class="headerlink" title="使用应用上下文"></a>使用应用上下文</h4><p>Spring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的。<br><br>AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。<br><br><strong>AnnotationConfigWebApplicationContext</strong>：从一个或多个基于Java的配置类中加载Spring Web应用上下文。<br><br>ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。<br><br>FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。<br><br><strong>XmlWebApplicationContext</strong>：从Web应用下的一个或多个XML配置文件中加载上下文定义。</p>
<p>例子：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml");</div><div class="line">    ApplicationContext context = new ClassPathXmlApplicationContext("knight.xml");</div><div class="line">    ``` </div><div class="line"></div><div class="line">使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：FileSystemXmlApplicationContext在指定的文件系统路径下查找knight.xml文件；而ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件）下查找knight.xml文件。</div><div class="line"></div><div class="line">如果你想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext：</div><div class="line">```java </div><div class="line">ApplicationContext context = new AnnotationConfigApplicationContext(com.springinaction.</div><div class="line">                                knights.config.KnightConfig.class);</div><div class="line">``` </div><div class="line"></div><div class="line">### bean的生命周期</div><div class="line"></div><div class="line">1. Spring对bean进行实例化；</div><div class="line">2. Spring将值和bean的引用注入到bean对应的属性中；</div><div class="line">3. 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</div><div class="line">4. 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</div><div class="line">5. 果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</div><div class="line">6. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</div><div class="line">7. 如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</div><div class="line">8. 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</div><div class="line">9. 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</div><div class="line">10. 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</div><div class="line"></div><div class="line">写个例子：有三个java文件OneBean.java,PostService.java,Test.java,还有个上下文依赖关系文件applicationContext.xml</div><div class="line"></div><div class="line">**applicationContext.xml**</div><div class="line">```xml</div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">       xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">       xmlns:aop="http://www.springframework.org/schema/aop"  </div><div class="line">       xmlns:p="http://www.springframework.org/schema/p" </div><div class="line">    xsi:schemaLocation="  </div><div class="line">    http://www.springframework.org/schema/context  </div><div class="line">    http://www.springframework.org/schema/context/spring-context.xsd  </div><div class="line">    http://www.springframework.org/schema/beans  </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd  </div><div class="line">    http://www.springframework.org/schema/aop  </div><div class="line">    http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; </div><div class="line">    </div><div class="line">    &lt;bean id="oneBean" class="com.bean.life.OneBean" init-method="myInit" destroy-method="myDestroy" &gt;</div><div class="line">        &lt;property name="beanName1" value="555"&gt;&lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;bean id="postService" class="com.bean.life.PostService"&gt;&lt;/bean&gt;</div><div class="line">   &lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p><strong>OneBean.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bean.life;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</div><div class="line"></div><div class="line"><span class="comment">//如果设置了init-method="myInit" destroy-method="myDestroy" </span></div><div class="line"><span class="comment">//两个方法（推荐使用）就不需要实现InitializingBean,DisposableBean</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneBean</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> ,<span class="title">BeanFactoryAware</span>,</span></div><div class="line">        <span class="title">ApplicationContextAware</span>,<span class="title">InitializingBean</span>,<span class="title">DisposableBean</span>  &#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String beanName1 = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanName1</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> beanName1;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName1</span><span class="params">(String beanName1)</span> </span>&#123;<span class="keyword">this</span>.beanName1 = beanName1;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">OutName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> beanName1;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OneBean</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"（1）我是OneBean的构造函数"</span>);</div><div class="line">		System.out.println(beanName1);</div><div class="line">	&#125;	</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（2）将被设置的bean名称！"</span>+name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory arg0)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"-------------------------------------------------"</span>);</div><div class="line">		System.out.println(<span class="string">"（3）OneBean实现BeanFactoryAware后得到FactoryBean"</span></div><div class="line">                          + <span class="string">"(在OneBean.java输出)："</span>+arg0);</div><div class="line">		System.out.println(<span class="string">"    FactoryBean得到的OneBean与this本身相等："</span></div><div class="line">                                +(arg0.getBean(<span class="string">"oneBean"</span>) == <span class="keyword">this</span>));</div><div class="line">		System.out.println(<span class="string">"    "</span>+beanName1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"------------------------------------------------"</span>);</div><div class="line">		System.out.println(<span class="string">"（4）OneBean实现ApplicationContextAware后得到ApplicationContext"</span></div><div class="line">                           +<span class="string">" (在OneBean.java输出)："</span>+applicationContext);</div><div class="line">		System.out.println(<span class="string">"    ApplicationContext得到的OneBean与this本身相等："</span></div><div class="line">                            +(applicationContext.getBean(<span class="string">"oneBean"</span>) == <span class="keyword">this</span>));</div><div class="line">		System.out.println(<span class="string">"    "</span>+beanName1);</div><div class="line">		System.out.println(<span class="string">"---------------------------------------------------"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（6）运行afterPropertiesSet()方法"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"（7）执行自己定义初始化的方法myInit()（需要在xml里面配置）"</span>);&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestroy</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"（10）执行自己定义Destroy()方法（需要在xml里面配置）"</span>);&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（9）执行destroy()方法"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>PostService.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bean.life;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostService</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		 System.out.println(<span class="string">"（5）---这是init之前执行的方法postProcessBeforeInitialization---"</span>);</div><div class="line">		 </div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">		<span class="comment">// TODO 自动生成的方法存根</span></div><div class="line">		System.out.println(<span class="string">"（8）----这是init之后执行的方法postProcessAfterInitialization----"</span>);</div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Test.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bean.life;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.AbstractApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.service.ApplicationContextUtil;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"main---初始化之前！"</span>);</div><div class="line">		ApplicationContext applicationContext = ApplicationContextUtil.getAc();</div><div class="line">		System.out.println(<span class="string">"main---得到applicationContext后！"</span>);</div><div class="line">		OneBean oneBean = (OneBean) applicationContext.getBean(<span class="string">"oneBean"</span>);</div><div class="line">		System.out.println(<span class="string">"OneBean中的OutName方法调用："</span>+oneBean.OutName());</div><div class="line">		AbstractApplicationContext aac =(AbstractApplicationContext) applicationContext;</div><div class="line">		aac.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>执行结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">main---初始化之前！</div><div class="line">七月 14, 2017 4:19:48 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh</div><div class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy</div><div class="line">七月 14, 2017 4:19:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</div><div class="line">信息: Loading XML bean definitions from class path resource [applicationContext.xml]</div><div class="line">（1）我是OneBean的构造函数</div><div class="line">null</div><div class="line">（2）将被设置的bean名称！oneBean</div><div class="line">-------------------------------------------------------------------------</div><div class="line">（3）OneBean实现BeanFactoryAware后得到FactoryBean(在OneBean.java输出)：org.springframework.beans.factory.support.DefaultListableBeanFactory@b44eaa0: defining beans [oneBean,postService]; root of factory hierarchy</div><div class="line">    FactoryBean得到的OneBean与this本身相等：true</div><div class="line">    555</div><div class="line">---------------------------------------------------------------------------</div><div class="line">（4）OneBean实现ApplicationContextAware后得到ApplicationContext(在OneBean.java输出)：org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy</div><div class="line">    ApplicationContext得到的OneBean与this本身相等：true</div><div class="line">    555</div><div class="line">---------------------------------------------------------------------------</div><div class="line">（5）---这是init之前执行的方法postProcessBeforeInitialization---</div><div class="line">（6）运行afterPropertiesSet()方法</div><div class="line">（7）执行自己定义初始化的方法myInit()（需要在xml里面配置）</div><div class="line">（8）----这是init之后执行的方法postProcessAfterInitialization----</div><div class="line">main---得到applicationContext后！</div><div class="line">OneBean中的OutName方法调用：555</div><div class="line">七月 14, 2017 4:19:48 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose</div><div class="line">信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@6a047934: startup date [Fri Jul 14 16:19:48 CST 2017]; root of context hierarchy</div><div class="line">（9）执行destroy()方法</div><div class="line">（10）执行自己定义Destroy()方法（需要在xml里面配置）</div></pre></td></tr></table></figure></p>
<h3 id="spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h3><p>Spring框架由6个定义良好的模块分类组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Data access &amp; integration</div><div class="line">  |----JDBC</div><div class="line">  |----OXM</div><div class="line">  |----Messaging</div><div class="line">  |----Transaction</div><div class="line">  |----ORM</div><div class="line">  |----JMS</div><div class="line"></div><div class="line">Web and remoting           \\Web与远程调用</div><div class="line">  |----Web </div><div class="line">  |----Web servlet</div><div class="line">  |----Web portlet</div><div class="line">  |----WebSocket</div><div class="line"></div><div class="line">Aspect-oriented programming  \\Spring的AOP模块</div><div class="line">  |----AOP</div><div class="line">  |----Aspects</div><div class="line"></div><div class="line">Instrumentation</div><div class="line">  |----Instrument Tomcat</div><div class="line">  |----Instrument</div><div class="line"></div><div class="line">Core Spring container        \\Spring核心容器</div><div class="line">  |----Beans</div><div class="line">  |----Core </div><div class="line">  |----Context </div><div class="line">  |----Expression</div><div class="line">  |----Context support</div><div class="line">Testing</div><div class="line">  |----Test</div></pre></td></tr></table></figure></p>
<ol>
<li>核心容器（Core Spring container ）</li>
</ol>
<ul>
<li>spring-core和spring-beans：提供框架的基础部分，包括控制反转和依赖注入的特性，BeanFactory是用工厂模式来实现的，使我们不用自己去创建单例对象，并将依赖的配置和设计与业务逻辑分开来。</li>
<li>spring-context模块是建立在前两者之上的，通过它可以使用框架风格（framework-style）的方法来访问对象，类似于JNDI服务注册。该模块集成了bean模块，并加入了国际化、事件传播、资源加载、透明化生成上下文，还支持Java EE特性如EJB、 JMX 和 basic remoting。context模块的关键是ApplicationContext接口。spring-context-support支持集成第三方库，如缓存、邮件、调度、模板引擎等。</li>
<li>spring-expression: 提供了强大的EL（ expression language）在运行状态查询和操纵对象，它支持属性的赋值，通过setter和getter方法设置和获取属性值、方法调用、访问数组 集合、逻辑和数学操纵、变量命名、通过IoC容器检索对象。</li>
</ul>
<ol>
<li>AOP和插装(Aspect-oriented programming )</li>
</ol>
<ul>
<li>spring-aop :模块提供了面向切面编程的实现，使我们可以定义方法拦截器和切点来使得分离功能独立的业务。使用基于源的元数据功能，我们还可以将行为信息集成到代码中，这和.NET的属性很相似。</li>
<li>spring-aspects :模块支持Spring 框架整合AspectJ.</li>
<li>spring-instrument 在特定容器中实现类插装和类加载器的实施 。 spring-instrument-tomcat包含Tomcat的Spring插装代理。</li>
</ul>
<ol>
<li>消息(Messaging)</li>
</ol>
<ul>
<li>spring-messaging 模块包含从 Message，MessageChannel，MessageHandler 等其他基于消息的基础应用中得到的抽象。该模块还包含一系列的注解来讲消息映射到方法上，和SpringMVC注解类似 。</li>
</ul>
<ol>
<li>数据访问控制(Data access &amp; integration)</li>
</ol>
<ul>
<li>spring-jdbc提供JDBC抽象层 ，使我们从繁重的JDBC编程中解脱出来，并且不再需要为解析不同的数据库的异常而烦恼。</li>
<li>spring-tx支持对所有POJO和实现了特定接口的类进行 编程式和申明式事务（ programmatic and declarative transaction ）管理。</li>
<li>spring-orm整合了流行的ORM（object-relational mapping ）应用程序接口，包括JPA、JDO和Hibernate。使用该模块我们可以任意使用这些ORM框架和Spring的其他功能（如上面的申明式事务管理进行组合。</li>
<li>spring-oxm为OXM（Object/XML mapping） 的实现提供抽象层，如 JAXB、Castor、XMLBeans、JiBX 和XStream。</li>
<li>spring-jms 是Java消息服务(Java Messaging Service)，包含产生和接受消息 。Spring Framework 4.1将它并入在spring-messaging 模块。</li>
</ul>
<ol>
<li>Web(Web and remoting)</li>
</ol>
<ul>
<li>spring-web 包含基本的面向网络的集成特性，如文件分部上传，使用Servet监听器和面向网络的应用上下文初始化IoC容器。他还包括 HTTP 客户端和网络相关的 Spring远程支持。</li>
<li>spring-webmvc 也被成为 Web-Servlet 模块，包含Spring的模型-视图-控制器（model-view-controller，MVC) 和 REST Web Services。 Spring  MVC 框架是得实体模型代码和网络表单清楚地离开来，还可以轻松集成Spring框架的其他特性。</li>
<li>spring-webmvc-portlet 也被称为 Web-Portlet 模块，在Portlet 容器中实现MVC，并且能使用spring-webmvc 模块的功能。</li>
</ul>
<ol>
<li>测试(Testing)</li>
</ol>
<ul>
<li>spring-test 模块支持单元测试 JUnit 、集成测试 TestNG和独立代码测试 mock objects。它支持加载和缓存 Spring ApplicationContexts。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaee </category>
            
            <category> spring </category>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaee spring 学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础 多形性[多态](java编程思想)]]></title>
      <url>http://mingcode.cn/2017/06/13/javaBase-%E5%A4%9A%E5%BD%A2%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="多形性多态"><a href="#多形性（多态）：" class="headerlink" title="多形性（多态）："></a>多形性（多态）：</h3><p><blockquote class="blockquote-center"><pre><br>“对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。)”<br>“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与<br>“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建<br>“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成<br>长”。                                                 ——–think in java<br>    </pre><br></blockquote><br><a id="more"></a></p>
<h3 id="具体知识点"><a href="#具体知识点" class="headerlink" title="具体知识点"></a>具体知识点</h3><h4 id="上溯造型"><a href="#上溯造型" class="headerlink" title="上溯造型"></a>上溯造型</h4><p>以一个简单的例子说明，类图如下：<br><img src="http://www.plantuml.com/plantuml/svg/IquiKh2fqTLLI2mjoS_DJyhCIULA1efPARnOsFDovJODJIw4398e0000"><br>在上面的例子中，automobile继承自car，因为继承树的画法是基础类位于最上方，所以称之为上溯造型。我们可以知道automobile是car的子类。所以可以这样定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">car sub = <span class="keyword">new</span> automobile();</div></pre></td></tr></table></figure>
<p>通过基础类的句柄可以调用子类的方法。</p>
<p>以下有一个利用上溯造型的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Note</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; value = val; &#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Note</div><div class="line">    middleC = <span class="keyword">new</span> Note(<span class="number">0</span>),</div><div class="line">    cSharp = <span class="keyword">new</span> Note(<span class="number">1</span>),</div><div class="line">    cFlat = <span class="keyword">new</span> Note(<span class="number">2</span>);</div><div class="line">&#125; <span class="comment">// Etc.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Instrument.play()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Wind objects are instruments</span></div><div class="line"><span class="comment">// because they have the same interface:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</div><div class="line"><span class="comment">// Redefine interface method:</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Wind.play()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">        i.play(Note.middleC);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Wind flute = <span class="keyword">new</span> Wind();</div><div class="line">        tune(flute); <span class="comment">// Upcasting</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>有一个问题：</strong> 编译器怎样才能知道 Instrument句柄指向的是一个 Wind，而不是一个Brass 或Stringed 呢？</p>
</blockquote>
<p>这里就涉及到了方法调用的绑定了，java主要是使用“后期绑定”，后期绑定也叫作“动态绑定”或“运行期绑定”。<br><br>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。<br><br>Java 中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成<code>final</code>。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。为什么要把一个方法声明成final 呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，<code>它可有效地“关闭”动态绑定</code>，或者告诉编译器不需要进行动态绑定。这样一来，<code>编译器就可为final 方法调用生成效率更高的代码</code>。</p>
<h4 id="覆盖与过载"><a href="#覆盖与过载" class="headerlink" title="覆盖与过载"></a>覆盖与过载</h4><p>“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。过载时返回值和参数数量，参数类型顺序不同，覆盖是返回值和参数完全一致。</p>
<h4 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h4><ul>
<li>包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。</li>
<li>如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为<code>基础类中的所有抽象方法提供方法定义</code>。如果<code>不这样做</code>（完全可以选择不做），则衍生类也会是抽象的，而且编译器会<code>强迫我们用abstract关键字标志</code>那个类的“抽象”本质。</li>
<li>即使<code>不包括任何abstract 方法</code>，亦可将一个类声明成“抽象类”。如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。</li>
</ul>
<p>以下用个图来说明<br><img src="http://www.plantuml.com/plantuml/svg/yymhBYagpKtDAr6mgT7LLGZFp4lXuafC0eec9fSe9ESa5XShUC8LLNCf085sDKn1hK9PVcQAGa5EOgL6fe8LK6L9QdfgaQOrLoqN5qGpo4IeDfng0G00"></p>
<p>上面就是一个继承关系,Wind属于Instrument，Wind实现了play方法。Instrument只是一个种类的抽象，定义了部分方法，没有实现，它不能具体实例化，但可以像下面的形式使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instrument wind = <span class="keyword">new</span> Wind();</div><div class="line">wind.play(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote><p>“interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：<em>方法名、自变量列表以及返回类型，但不规定方法主体</em>。接口也包含了基本数据类型的数据成员，但它们都<mark>默认为static 和final</mark>。接口只提供一种形式，并不提供实施的细节。</p>
<footer><strong>think in java</strong></footer></blockquote>
<ul>
<li><p>可将一个接口中的方法声明明确定义为“public”。但即便不明确定义，它们也会默认为 public。所以在实现一个接口的时候，来自接口的方法必须定义成public。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java 编译器不允许我们那样做。</p>
</li>
<li><p>创建一个新类时，可以上溯到它所实现的接口上面。</p>
</li>
<li><p>关于<code>&quot;多继承&quot;(P175)</code></p>
<p>如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于 implements关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面有个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;&#125;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span></span></div><div class="line"><span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">CanFly</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span> </span>&#123; x.fight(); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span> </span>&#123; x.swim(); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(CanFly x)</span> </span>&#123; x.fly(); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionCharacter x)</span> </span>&#123; x.fight(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Hero i = <span class="keyword">new</span> Hero();</div><div class="line">        t(i); <span class="comment">// Treat it as a CanFight</span></div><div class="line">        u(i); <span class="comment">// Treat it as a CanSwim</span></div><div class="line">        v(i); <span class="comment">// Treat it as a CanFly</span></div><div class="line">        w(i); <span class="comment">// Treat it as an ActionCharacter</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>当继承和接口实现中出现相同的方法标签<code><mark>fight()</mark></code>(在ActionCharacter类和CanFight接口中)，接口的可以从继承中实现。</li>
<li><p>上述例子已向我们揭示了接口最关键的作用，也是使用接口最重要的一个原因：能上溯造型至多个基础类。</p>
<blockquote>
<ul>
<li><em>这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？</em></li>
</ul>
</blockquote>
</li>
<li><p>若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类</p>
</li>
</ol>
<ul>
<li><p>通过继承扩展接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span></span></div><div class="line">  <span class="keyword">extends</span> <span class="title">DangerousMonster</span>, <span class="title">Lethal</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常，我们只能对单独一个类应用 extends（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，extends可能引用多个基础接口。如上，接口的名字只是简单地使用逗号分隔。</p>
</li>
</ul>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><blockquote><p>将一个类定义置入另一个类定义中。这就叫作“内部类”.</p>
<footer><strong>think in java</strong></footer></blockquote>
<h5 id="典型例子1"><a href="#典型例子1" class="headerlink" title="典型例子1:"></a>典型例子1:</h5><p>  一个外部类拥有一个特殊的方法，它会返回指向一个内部类的句柄。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07.parcel2;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String label;</div><div class="line">        Destination(String whereTo) &#123;</div><div class="line">            label = whereTo;</div><div class="line">        &#125;</div><div class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</div><div class="line">        Contents c = cont();</div><div class="line">        Destination d = to(dest);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel2 p = <span class="keyword">new</span> Parcel2();</div><div class="line">        p.ship(<span class="string">"Tanzania"</span>);</div><div class="line">        Parcel2 q = <span class="keyword">new</span> Parcel2();</div><div class="line">        <span class="comment">// Defining handles to inner classes:</span></div><div class="line">        Parcel2.Contents c = q.cont();</div><div class="line">        Parcel2.Destination d = q.to(<span class="string">"Borneo"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

若想在除外部类非static 方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为“外部类名.内部类名”，就象 main()中展示的那样
</code></pre><h5 id="内部类和上溯造型"><a href="#内部类和上溯造型" class="headerlink" title="内部类和上溯造型"></a>内部类和上溯造型</h5><p>  以下将展示通过内部类隐藏具体实施细节的例子</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07.parcel3;</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel3</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">extends</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String label;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</div><div class="line">            label = whereTo;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel3 p = <span class="keyword">new</span> Parcel3();</div><div class="line">        Contents c = p.cont();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">        <span class="comment">// Illegal -- can't access private class:</span></div><div class="line">        <span class="comment">//! Parcel3.PContents c = p.new PContents();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

&gt;&gt; *Contents 和Destination 代表可由客户程序员使用的接口（记住&lt;mark&gt;接口会将自己的所有成员都变成public属性&lt;/mark&gt;）。为方便起见，它们置于单独一个文件里，但原始的 Contents 和Destination 在它们自己的文件中是&lt;mark&gt;相互public&lt;/mark&gt; 的。*

客户程序员对这些成员的认识与访问将会受到限制。事实上，我们甚至&lt;mark&gt;不能下溯造型到一个 private内部类&lt;/mark&gt;（或者一个 protected 内部类，除非自己本身便是一个继承者），因为我们不能访问名字。

普通（非内部）类&lt;mark&gt;不可&lt;/mark&gt;设为private或 protected——只允许 public或者“友好的”。
</code></pre><h5 id="方法和作用域中的内部类p181"><a href="#方法和作用域中的内部类-P181" class="headerlink" title="方法和作用域中的内部类(P181)"></a>方法和作用域中的内部类<code>(P181)</code></h5><p>  我们在一个方法甚至一个任意的作用域内创建内部类。(1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。(2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。</p>
<p>  在下面这个例子里，将修改前面的代码，以便使用：</p>
<ol>
<li>在一个方法内定义的类</li>
<li>在方法的一个作用域内定义的类</li>
<li>一个匿名类，用于实现一个接口</li>
<li>一个匿名类，用于扩展拥有非默认构建器的一个类</li>
<li>一个匿名类，用于执行字段初始化</li>
<li><p>一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c07.innerscopes;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; i = x; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">            <span class="keyword">private</span> String label;</div><div class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</div><div class="line">                label = whereTo;</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel4 p = <span class="keyword">new</span> Parcel4();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//另外一个例子-------不同的作用域，和变量类似</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(b) &#123;</div><div class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123;</div><div class="line">                <span class="keyword">private</span> String id;</div><div class="line">                TrackingSlip(String s) &#123;</div><div class="line">                    id = s;</div><div class="line">                &#125;</div><div class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</div><div class="line">            &#125;</div><div class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</div><div class="line">            String s = ts.getSlip();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Can't use it here! Out of scope:</span></div><div class="line">        <span class="comment">//! TrackingSlip ts = new TrackingSlip("x");</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; internalTracking(<span class="keyword">true</span>); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel5 p = <span class="keyword">new</span> Parcel5();</div><div class="line">        p.track();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//另外一个例子-------返回匿名类，并实现接口</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">cont</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">        &#125;; <span class="comment">// Semicolon required in this case</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel6 p = <span class="keyword">new</span> Parcel6();</div><div class="line">        Contents c = p.cont();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"><span class="comment">/*这种奇怪的语法要表达的意思是：“创建从 Contents 衍生出来的匿名类的一个对象”。</span></div><div class="line">由 new表达式返回的句柄会自动上溯造型成一个Contents 句柄。匿名内部类的语法其实要表达的是：</div><div class="line">class MyContents implements Contents &#123;</div><div class="line">    private int i = 11;</div><div class="line">    public int value() &#123; return i; &#125;</div><div class="line">&#125;</div><div class="line">return new MyContents();*/</div><div class="line"></div><div class="line"><span class="comment">//当继承的基础类含有带参数的构造器时-------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="comment">// Base constructor call:</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;; <span class="comment">// Semicolon required</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</div><div class="line">        Wrapping w = p.wrap(<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*这里的匿名内部类可以调用构造函数*/</span></div><div class="line"></div><div class="line"><span class="comment">//下面是初始化匿名内部类中的字段例子</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</div><div class="line">    <span class="comment">// Argument must be final to use inside</span></div><div class="line">    <span class="comment">// anonymous inner class:</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(<span class="keyword">final</span> String dest)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</div><div class="line">            <span class="keyword">private</span> String label = dest;                <span class="comment">//^_^</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel8 p = <span class="keyword">new</span> Parcel8();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：*/</span></div><div class="line"><span class="comment">/*若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是</span></div><div class="line">我们将dest()的自变量设为final 的原因。*/</div><div class="line"></div><div class="line"><span class="comment">//使用构造快来，来实现匿名内部类的成员初始化</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel9</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">dest</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</div><div class="line">            <span class="comment">//-----------------------------------------------------</span></div><div class="line">            <span class="comment">// Instance initialization for each object: 这里使用实例初始化         </span></div><div class="line">            &#123;</div><div class="line">                cost = Math.round(price);</div><div class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</div><div class="line">                System.out.println(<span class="string">"Over budget!"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//-----------------------------------------------------</span></div><div class="line">            <span class="keyword">private</span> String label = dest;</div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel9 p = <span class="keyword">new</span> Parcel9();</div><div class="line">        Destination d = p.dest(<span class="string">"Tanzania"</span>, <span class="number">101.395F</span>);</div><div class="line">        System.out.println(d.readLabel());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*结果如下</span></div><div class="line">Over budget!</div><div class="line">Tanzania</div><div class="line"></div><div class="line">实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们**不能对实例初始化模块进行过载**处</div><div class="line">理，所以只能拥有这些构建器的其中一个。</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="内部类链接到外部类"><a href="#内部类链接到外部类" class="headerlink" title="内部类链接到外部类"></a>内部类链接到外部类</h5><p>  创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。如下代码：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object[] o;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        o = <span class="keyword">new</span> Object[size];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(next &lt; o.length) &#123;</div><div class="line">            o[next] = x;</div><div class="line">            next++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> i == o.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> o[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(i &lt; o.length) i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SSelector();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Sequence s = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">        s.add(Integer.toString(i));</div><div class="line"></div><div class="line">        Selector sl = s.getSelector();</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!sl.end()) &#123;</div><div class="line">            System.out.println((String)sl.current());</div><div class="line">            sl.next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="static内部类"><a href="#static内部类" class="headerlink" title="static内部类"></a>static内部类</h5><p>  使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：</p>
<ol>
<li>它的创建是不需要依赖于外围类的。</li>
<li><p>它不能使用任何外围类的非static成员变量和方法。</p>
<p>下面有个网上摘抄的demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String sex;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"chenssy"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">    *静态内部类</div><div class="line">    */</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;</div><div class="line">        <span class="comment">/* 在静态内部类中可以存在静态成员 */</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _name1 = <span class="string">"chenssy_static"</span>;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="comment">/* </span></div><div class="line">            * 静态内部类只能访问外围类的静态成员变量和方法</div><div class="line">            * 不能访问外围类的非静态成员变量和方法</div><div class="line">            */</div><div class="line">            System.out.println(<span class="string">"OutClass name :"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 非静态内部类</div><div class="line">    */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;</div><div class="line">        <span class="comment">/* 非静态内部类中不能存在静态成员 */</span></div><div class="line">        <span class="keyword">public</span> String _name2 = <span class="string">"chenssy_inner"</span>;</div><div class="line">        <span class="comment">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"OuterClass name："</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">    * <span class="doctag">@desc</span> 外围类方法</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">/* 外围类访问静态内部类：内部类. */</span></div><div class="line">        System.out.println(InnerClass1._name1);</div><div class="line">        <span class="comment">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span></div><div class="line">        <span class="keyword">new</span> InnerClass1().display();</div><div class="line">        </div><div class="line">        <span class="comment">/* 非静态内部的创建需要依赖于外围类 */</span></div><div class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().new InnerClass2();</div><div class="line">        <span class="comment">/* 方位非静态内部类的成员需要使用非静态内部类的实例 */</span></div><div class="line">        System.out.println(inner2._name2);</div><div class="line">        inner2.display();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</div><div class="line">        outer.display();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    ----------------</div><div class="line">    Output:</div><div class="line">    chenssy_static</div><div class="line">    OutClass name :chenssy</div><div class="line">    chenssy_inner</div><div class="line">    OuterClass name：chenssy</div></pre></td></tr></table></figure>
<p>通常，我们不在一个接口里设置任何代码，但 static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static 内部类只位于接口的命名空间内部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line">      <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">          <span class="keyword">int</span> i, j, k;</div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">          <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="引用外部类对象"><a href="#引用外部类对象" class="headerlink" title="引用外部类对象"></a>引用外部类对象</h5><p>  有些时候，我们想告诉其他某些对象创建它某个内部类的一个对象。为达到这个目的，必须在 new表达式中提供指向其他外部类对象的一个句柄，就象下面这样：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String label;</div><div class="line">        Destination(String whereTo) &#123;</div><div class="line">            label = whereTo;</div><div class="line">        &#125;</div><div class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Parcel11 p = <span class="keyword">new</span> Parcel11();</div><div class="line">        <span class="comment">// Must use instance of outer class</span></div><div class="line">        <span class="comment">// to create an instances of the inner class:----------注意外部类的引用 p</span></div><div class="line">        Parcel11.Contents c = p.new Contents();</div><div class="line">        Parcel11.Destination d = p.new Destination(<span class="string">"Tanzania"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="从内部类继承"><a href="#从内部类继承" class="headerlink" title="从内部类继承"></a>从内部类继承</h5><p>  当继承内部类时，有一个很重要的问题，内部类必须要在外部类初始化，并且有一个对象句柄才能使用，所以在这里，继承内部类后的类，在实例化时，要使的他与所继承类的外部类有联系，通过下面代码展现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</div><div class="line">    <span class="comment">//! InheritInner() &#123;&#125; // Won't compile</span></div><div class="line">    InheritInner(WithInner wi) &#123;</div><div class="line">        wi.<span class="keyword">super</span>();                 <span class="comment">//super()调用</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</div><div class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi); <span class="comment">//建立联系</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="内部类继承覆盖"><a href="#内部类继承覆盖" class="headerlink" title="内部类继承覆盖"></a>内部类继承覆盖</h5><p>  继承时，内部类的覆盖要明确指明,如：<figure class="highlight plain"><figcaption><span>class Yolk extends Egg2.Yolk```,下面的书上的一个例子。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```java</div><div class="line">  class Egg2 &#123;</div><div class="line">      protected class Yolk &#123;</div><div class="line">          public Yolk() &#123;</div><div class="line">              System.out.println(&quot;Egg2.Yolk()&quot;);</div><div class="line">          &#125;</div><div class="line">          public void f() &#123;</div><div class="line">              System.out.println(&quot;Egg2.Yolk.f()&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private Yolk y = new Yolk();</div><div class="line"></div><div class="line">      public Egg2() &#123;</div><div class="line">          System.out.println(&quot;New Egg2()&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      public void insertYolk(Yolk yy) &#123; y = yy; &#125;</div><div class="line"></div><div class="line">      public void g() &#123; y.f(); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public class BigEgg2 extends Egg2 &#123;</div><div class="line">      public class Yolk extends Egg2.Yolk &#123;</div><div class="line">          public Yolk() &#123;</div><div class="line">              System.out.println(&quot;BigEgg2.Yolk()&quot;);</div><div class="line">          &#125;</div><div class="line">          public void f() &#123;</div><div class="line">              System.out.println(&quot;BigEgg2.Yolk.f()&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      public BigEgg2() &#123; insertYolk(new Yolk()); &#125;</div><div class="line"></div><div class="line">      public static void main(String[] args) &#123;</div><div class="line">          Egg2 e2 = new BigEgg2();</div><div class="line">          e2.g();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  方法 insertYolk()允许BigEgg2将它自己的某个 Yolk 对象上溯造型至 Egg2 的y 句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。<br>  输出结果如下：<br><br>  Egg2.Yolk()<br><br>  New Egg2()<br><br>  Egg2.Yolk()<br><br>  BigEgg2.Yolk()<br><br>  BigEgg2.Yolk.f()<br></p>
<h5 id="769-为什么要用内部类控制框架p192"><a href="#7-6-9-为什么要用内部类：控制框架（P192）" class="headerlink" title="7.6.9 为什么要用内部类：控制框架（P192）"></a>7.6.9 为什么要用内部类：控制框架（P192）</h5><pre><code>自己看代码研究（记得调试观察）
</code></pre><h4 id="构建器和多形性"><a href="#构建器和多形性" class="headerlink" title="构建器和多形性"></a>构建器和多形性</h4><h5 id="构建器的调用顺序"><a href="#构建器的调用顺序" class="headerlink" title="构建器的调用顺序"></a>构建器的调用顺序</h5><p>  基础类的构建器肯定在一个衍生类的构建器中调用，而且逐渐向上链接，原因在于：检查对象是否得到了正确的构建。一个衍生类只能访问它自己的成员，不能访问基础类的成员（这些成员通常都具有private 属性）。只有基础类的构建器在初始化自己的元素时才知道正确的方法以及拥有适当的权限。<br><br>  若我们没有明确指定对一个基础类构建器的调用，它就会“默默”地调用默认构建器。如果不存在默认构建器，编译器就会报告一个错误（若某个类没有构建器，编译器会自动组织一个默认构建器）。<br><br>  下面是个例子<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</div><div class="line">    Meal() &#123; System.out.println(<span class="string">"Meal()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</div><div class="line">    Bread() &#123; System.out.println(<span class="string">"Bread()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</div><div class="line">    Cheese() &#123; System.out.println(<span class="string">"Cheese()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</div><div class="line">    Lettuce() &#123; System.out.println(<span class="string">"Lettuce()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</div><div class="line">    Lunch() &#123; System.out.println(<span class="string">"Lunch()"</span>);&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</div><div class="line">    PortableLunch() &#123;</div><div class="line">        System.out.println(<span class="string">"PortableLunch()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</div><div class="line">    Bread b = <span class="keyword">new</span> Bread();</div><div class="line">    Cheese c = <span class="keyword">new</span> Cheese();</div><div class="line">    Lettuce l = <span class="keyword">new</span> Lettuce();</div><div class="line">    Sandwich() &#123;</div><div class="line">        System.out.println(<span class="string">"Sandwich()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Sandwich();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果如下：</span></div><div class="line"><span class="comment">//Meal()</span></div><div class="line"><span class="comment">//Lunch()</span></div><div class="line"><span class="comment">//PortableLunch()</span></div><div class="line"><span class="comment">//Bread()</span></div><div class="line"><span class="comment">//Cheese()</span></div><div class="line"><span class="comment">//Lettuce()</span></div><div class="line"><span class="comment">//Sandwich()</span></div></pre></td></tr></table></figure></p>
<ol>
<li>调用基础类构建器。这个步骤会不断重复下去，首先得到构建的是分级结构的根部，然后是下一个衍生类，等等。直到抵达最深一层的衍生类。</li>
<li>按声明顺序调用成员初始化模块。</li>
<li>调用衍生构建器的主体。</li>
</ol>
<h4 id="继承和-finalize"><a href="#继承和-finalize" class="headerlink" title="继承和 finalize()"></a>继承和 finalize()</h4><ol>
<li>通过合成，程序完结时，一定会调用finalize()释放。离衍生类最近的成员类先释放。</li>
<li><p>如果继承的父类，没有覆盖finalize()方法且没有调用super.finalize()，那衍生调用finalize后，父类不会在finalize。</p>
<p>例子在<mark>P199</mark></p>
</li>
</ol>
<h4 id="一个关于初始化需要注意的问题"><a href="#一个关于初始化需要注意的问题" class="headerlink" title="一个关于初始化需要注意的问题"></a>一个关于初始化需要注意的问题</h4><p>  先看代码:<br></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">    Glyph() &#123;</div><div class="line">        System.out.println(<span class="string">"Glyph() before draw()"</span>);</div><div class="line">        draw();</div><div class="line">        System.out.println(<span class="string">"Glyph() after draw()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> radius = <span class="number">1</span>;</div><div class="line"></div><div class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</div><div class="line">        radius = r;</div><div class="line">        System.out.println(<span class="string">"RoundGlyph.RoundGlyph(), radius = "</span> + radius);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"RoundGlyph.draw(), radius = "</span> + radius);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果如下：</div><div class="line">Glyph() <span class="function">before <span class="title">draw</span><span class="params">()</span></span></div><div class="line">RoundGlyph.<span class="title">draw</span><span class="params">()</span>, radius = <span class="number">0</span></div><div class="line">Glyph() <span class="function">after <span class="title">draw</span><span class="params">()</span></span></div><div class="line">RoundGlyph.<span class="title">RoundGlyph</span><span class="params">()</span>, radius = <span class="number">5</span></div></pre></td></tr></table></figure>
<ol>
<li>子类调用父类构造器时，因为子类重写了抽象类的方法，而那时子类的成员并没被初始化。说以父类构造器调用会出现意想不到的错误。</li>
<li>一般不要再构造器中调用方法来初始化类。</li>
<li>在构建器内唯一能够安全调用的是在基础类中具有final 属性的那些方法（也适用于<mark>private方法，它们自动具有final 属性</mark>）。这些方法不能被覆盖，所以不会出现上述潜在的问题。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 基础 </category>
            
            <category> 多形性 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础 类再生(java编程思想)]]></title>
      <url>http://mingcode.cn/2017/05/27/javaBase-%E7%B1%BB%E5%86%8D%E7%94%9F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<blockquote>
<h3 id="1-关于合成与继承"><a href="#1-关于合成与继承" class="headerlink" title="1 .关于合成与继承"></a>1 .关于合成与继承</h3></blockquote>
<ul>
<li><p>合成：合成只需在新类里简单地置入对象句柄即可，更加灵活，对象会被置null值，基础数据类型置0或者false。</p>
</li>
<li><p>继承：在新类后面使用关键字extends加上一个基础类，则可完成继承，新类可以继承基础类的所有非private变量和方法。</p>
<a id="more"></a>
</li>
<li><p>一般合成与继承两种技术结合起来使用</p>
</li>
<li><p>只有在清楚知道继承在所有方法中最有效的前提下，才可考虑继承。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。</p>
</li>
</ul>
<blockquote>
<h3 id="2-final关键字"><a href="#2-final关键字" class="headerlink" title="2 .final关键字"></a>2 .final关键字</h3></blockquote>
<h4 id="final数据"><a href="#final数据：" class="headerlink" title="final数据："></a>final数据：</h4><p>（1）编译期常数，它永远不会改变，对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型。无论static还是final字段，都只能存储一个数据，而且不得改变。（2）但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。</p>
<ul>
<li><ol>
<li>空白final：允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。</li>
</ol>
</li>
<li><ol>
<li>final自变量：允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> </span>&#123;</div><div class="line">    <span class="comment">//! g = new Gizmo(); // Illegal g is final</span></div><div class="line">    g.spin();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">without</span><span class="params">(Gizmo g)</span> </span>&#123;</div><div class="line">    g = <span class="keyword">new</span> Gizmo(); <span class="comment">// OK g not final</span></div><div class="line">    g.spin();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="final方法"><a href="#final方法：" class="headerlink" title="final方法："></a>final方法：</h4><p>第一个是为方法“上锁”，防止任何继承类改变它的本来含义。第二是为程序执行的效率<code>[p155]</code>类内所有 private 方法都自动成为 final 。</p>
<h4 id="final-类"><a href="#final-类：" class="headerlink" title="final 类："></a>final 类：</h4><p>整个类都是final（在它的定义前冠以 final 关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。</p>
<blockquote>
<h3 id="3-继承初始化"><a href="#3-继承初始化" class="headerlink" title="3 .继承初始化"></a>3 .继承初始化</h3><p>先看代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">9</span>;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    Insect() &#123;</div><div class="line">        prt(<span class="string">"i = "</span> + i + <span class="string">", j = "</span> + j);</div><div class="line">        j = <span class="number">39</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x1 = prt(<span class="string">"static Insect.x1 initialized"</span>);</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">        <span class="keyword">return</span> <span class="number">47</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insect</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = prt(<span class="string">"Beetle.k initialized"</span>);</div><div class="line">    Beetle() &#123;</div><div class="line">        prt(<span class="string">"k = "</span> + k);</div><div class="line">        prt(<span class="string">"j = "</span> + j);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x2 =prt(<span class="string">"static Beetle.x2 initialized"</span>);</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">        <span class="keyword">return</span> <span class="number">63</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        prt(<span class="string">"Beetle constructor"</span>);</div><div class="line">        Beetle b = <span class="keyword">new</span> Beetle();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在看结果</p>
<pre><code>static Insect.x initialized
static Beetle.x initialized
Beetle constructor
i = 9, j = 0
Beetle.k initialized
k = 63
j = 39
</code></pre><blockquote>
<blockquote>
<p>父类静态变量（静态代码块，静态成员变量）–&gt; 子类静态变量（静态代码块，静态成员变量）–&gt;main函数–&gt;父类成员变量–&gt;父类构造器–&gt;子类成员变量–&gt;子类构造器</p>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 基础 </category>
            
            <category> 类再生 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-工厂模式 GOF-Factory-Method]]></title>
      <url>http://mingcode.cn/2017/05/02/GOF-Factory-Method/</url>
      <content type="html"><![CDATA[<h1 id="工厂方法模式-factory-method"><a href="#工厂方法模式-（Factory-Method）" class="headerlink" title="工厂方法模式 （Factory Method）"></a>工厂方法模式 （Factory Method）</h1><blockquote><p>工厂方法模式的意义是定义一个创建产品对象的<code>工厂接口</code>，将实际创建工作<code>推迟到子类</code>当中。核心工厂类不再负责产品的创建，<a id="more"></a>这样核心类成为一个<code>抽象工厂</code>角色，仅负责具体工厂子类必须<code>实现</code>的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
<footer><strong>Java研究组织</strong><cite><a href="http://tech.it168.com/a2009/0223/266/000000266400.shtml" target="_blank" rel="external">Java设计模式之工厂方法模式</a></cite></footer></blockquote>
<h2 id="工厂方法模式分为三种"><a href="#工厂方法模式分为三种" class="headerlink" title="工厂方法模式分为三种"></a>工厂方法模式分为三种</h2><pre><code>1. 普通工厂模式
2. 多个工厂方法模式
3. 静态工厂方法模式
</code></pre><h1 id="一普通工厂模式"><a href="#一-普通工厂模式" class="headerlink" title="一,普通工厂模式:"></a>一,普通工厂模式:</h1><blockquote>
<p>建立一个工厂类，对实现了同一接口的一些类进行实例的创建。<br>设计参考下图：</p>
</blockquote>
<img src="http://opdy5wv5e.bkt.clouddn.com/GOF/1/GOF-1.PNG" width="450" height="450" title="图1-1 简单工厂模式UML设计图">
<ul>
<li><p>创建Sender接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分别实现两个接口的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"this is phonesender!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"this is messagesender!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后创建工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (<span class="string">"phone"</span>.equals(type)) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"msg"</span>.equals(type)) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"请输入正确的类型!"</span>);  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();  </div><div class="line">        Sender sender = factory.produce(<span class="string">"msg"</span>);  </div><div class="line">        sender.Send();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>输出结果：<code>this is messagesender!</code></p>
</blockquote>
</li>
</ul>
<h1 id="二多个工厂方法模式"><a href="#二，多个工厂方法模式" class="headerlink" title="二，多个工厂方法模式"></a>二，多个工厂方法模式</h1><blockquote>
<p>是对普通工厂方法模式的改进，普通工厂方法模式中，字符串传递容易出错，可以通过多个工厂方法创建对象。参考图如下：</p>
</blockquote>
<img src="http://opdy5wv5e.bkt.clouddn.com/GOF/1/GOF-2.PNG" width="450" height="450" title="图1-2 多工厂方法UML设计图">
<ul>
<li><p>修改简单工厂模式中的SendFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">producePhone</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneSender();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMessage</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageSender();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设计测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();  </div><div class="line">        Sender sender = factory.produceMessage();  </div><div class="line">        sender.Send();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试结果</p>
</li>
<li><blockquote>
<p>输出结果：<code>this is messagesender!</code></p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 工厂模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工厂模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[404]]></title>
      <url>http://mingcode.cn/2017/01/05//404/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://mingcode.cn/2017/01/05/hello-world/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><h1 id="上次服务器加wp的崩溃后现在终于又有了以后要写些东西了"><a href="#上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了" class="headerlink" title="上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了"></a>上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了</h1></blockquote>]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 默认 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
