<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础 多形性[多态](java编程思想)]]></title>
    <url>%2F2017%2F06%2F13%2FjavaBase-%E5%A4%9A%E5%BD%A2%E6%80%A7%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[多形性（多态）：“对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。)”“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成长”。 ——–think in java 具体知识点上溯造型以一个简单的例子说明，类图如下：在上面的例子中，automobile继承自car，因为继承树的画法是基础类位于最上方，所以称之为上溯造型。我们可以知道automobile是car的子类。所以可以这样定义 1car sub = new automobile(); 通过基础类的句柄可以调用子类的方法。 以下有一个利用上溯造型的例子 1234567891011121314151617181920212223242526272829303132package c07;class Note &#123;private int value;private Note(int val) &#123; value = val; &#125;public static final Note middleC = new Note(0), cSharp = new Note(1), cFlat = new Note(2);&#125; // Etc.class Instrument &#123; public void play(Note n) &#123; System.out.println("Instrument.play()"); &#125;&#125;// Wind objects are instruments// because they have the same interface:class Wind extends Instrument &#123;// Redefine interface method: public void play(Note n) &#123; System.out.println("Wind.play()"); &#125;&#125;public class Music &#123; public static void tune(Instrument i) &#123; // ... i.play(Note.middleC); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); tune(flute); // Upcasting &#125;&#125; 有一个问题： 编译器怎样才能知道 Instrument句柄指向的是一个 Wind，而不是一个Brass 或Stringed 呢？ 这里就涉及到了方法调用的绑定了，java主要是使用“后期绑定”，后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。Java 中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成final。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。为什么要把一个方法声明成final 呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final 方法调用生成效率更高的代码。 覆盖与过载“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。过载时返回值和参数数量，参数类型顺序不同，覆盖是返回值和参数完全一致。 抽象类和方法 包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。 如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为基础类中的所有抽象方法提供方法定义。如果不这样做（完全可以选择不做），则衍生类也会是抽象的，而且编译器会强迫我们用abstract关键字标志那个类的“抽象”本质。 即使不包括任何abstract 方法，亦可将一个类声明成“抽象类”。如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。 以下用个图来说明 上面就是一个继承关系,Wind属于Instrument，Wind实现了play方法。Instrument只是一个种类的抽象，定义了部分方法，没有实现，它不能具体实例化，但可以像下面的形式使用。 12Instrument wind = new Wind();wind.play(1); 接口“interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static 和final。接口只提供一种形式，并不提供实施的细节。 think in java 可将一个接口中的方法声明明确定义为“public”。但即便不明确定义，它们也会默认为 public。所以在实现一个接口的时候，来自接口的方法必须定义成public。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java 编译器不允许我们那样做。 创建一个新类时，可以上溯到它所实现的接口上面。 关于&quot;多继承&quot;(P175) 如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于 implements关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面有个例子： 12345678910111213141516171819202122232425import java.util.*;interface CanFight &#123;void fight();&#125;interface CanSwim &#123;void swim();&#125;interface CanFly &#123;void fly();&#125;class ActionCharacter &#123;public void fight() &#123;&#125;&#125;class Hero extends ActionCharacterimplements CanFight, CanSwim, CanFly &#123; public void swim() &#123;&#125; public void fly() &#123;&#125;&#125;public class Adventure &#123; static void t(CanFight x) &#123; x.fight(); &#125; static void u(CanSwim x) &#123; x.swim(); &#125; static void v(CanFly x) &#123; x.fly(); &#125; static void w(ActionCharacter x) &#123; x.fight(); &#125; public static void main(String[] args) &#123; Hero i = new Hero(); t(i); // Treat it as a CanFight u(i); // Treat it as a CanSwim v(i); // Treat it as a CanFly w(i); // Treat it as an ActionCharacter &#125;&#125; 当继承和接口实现中出现相同的方法标签fight()(在ActionCharacter类和CanFight接口中)，接口的可以从继承中实现。 上述例子已向我们揭示了接口最关键的作用，也是使用接口最重要的一个原因：能上溯造型至多个基础类。 这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？ 若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类 通过继承扩展接口 1234interface Vampire extends DangerousMonster, Lethal &#123; void drinkBlood();&#125; 通常，我们只能对单独一个类应用 extends（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，extends可能引用多个基础接口。如上，接口的名字只是简单地使用逗号分隔。 内部类将一个类定义置入另一个类定义中。这就叫作“内部类”. think in java 典型例子1: 一个外部类拥有一个特殊的方法，它会返回指向一个内部类的句柄。 1234567891011121314151617181920212223242526272829303132package c07.parcel2;public class Parcel2 &#123; class Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; public Destination to(String s) &#123; return new Destination(s); &#125; public Contents cont() &#123; return new Contents(); &#125; public void ship(String dest) &#123; Contents c = cont(); Destination d = to(dest); &#125; public static void main(String[] args) &#123; Parcel2 p = new Parcel2(); p.ship("Tanzania"); Parcel2 q = new Parcel2(); // Defining handles to inner classes: Parcel2.Contents c = q.cont(); Parcel2.Destination d = q.to("Borneo"); &#125;&#125; 若想在除外部类非static 方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为“外部类名.内部类名”，就象 main()中展示的那样 内部类和上溯造型 以下将展示通过内部类隐藏具体实施细节的例子 1234567891011121314151617181920212223242526272829303132333435363738package c07.parcel3;abstract class Contents &#123; abstract public int value();&#125;interface Destination &#123; String readLabel();&#125;public class Parcel3 &#123; private class PContents extends Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; protected class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; public Destination dest(String s) &#123; return new PDestination(s); &#125; public Contents cont() &#123; return new PContents(); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Parcel3 p = new Parcel3(); Contents c = p.cont(); Destination d = p.dest("Tanzania"); // Illegal -- can't access private class: //! Parcel3.PContents c = p.new PContents(); &#125;&#125; &gt;&gt; *Contents 和Destination 代表可由客户程序员使用的接口（记住&lt;mark&gt;接口会将自己的所有成员都变成public属性&lt;/mark&gt;）。为方便起见，它们置于单独一个文件里，但原始的 Contents 和Destination 在它们自己的文件中是&lt;mark&gt;相互public&lt;/mark&gt; 的。* 客户程序员对这些成员的认识与访问将会受到限制。事实上，我们甚至&lt;mark&gt;不能下溯造型到一个 private内部类&lt;/mark&gt;（或者一个 protected 内部类，除非自己本身便是一个继承者），因为我们不能访问名字。 普通（非内部）类&lt;mark&gt;不可&lt;/mark&gt;设为private或 protected——只允许 public或者“友好的”。 方法和作用域中的内部类(P181) 我们在一个方法甚至一个任意的作用域内创建内部类。(1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。(2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。 在下面这个例子里，将修改前面的代码，以便使用： 在一个方法内定义的类 在方法的一个作用域内定义的类 一个匿名类，用于实现一个接口 一个匿名类，用于扩展拥有非默认构建器的一个类 一个匿名类，用于执行字段初始化 一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package c07.innerscopes;interface Destination &#123; String readLabel();&#125;interface Contents &#123; int value();&#125;public class Wrapping &#123; private int i; public Wrapping(int x) &#123; i = x; &#125; public int value() &#123; return i; &#125;&#125;public class Parcel4 &#123; public Destination dest(String s) &#123; class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; return new PDestination(s); &#125; public static void main(String[] args) &#123; Parcel4 p = new Parcel4(); Destination d = p.dest("Tanzania"); &#125;&#125;//另外一个例子-------不同的作用域，和变量类似public class Parcel5 &#123; private void internalTracking(boolean b) &#123; if(b) &#123; class TrackingSlip &#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip() &#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip("slip"); String s = ts.getSlip(); &#125; // Can't use it here! Out of scope: //! TrackingSlip ts = new TrackingSlip("x"); &#125; public void track() &#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); p.track(); &#125;&#125; //另外一个例子-------返回匿名类，并实现接口public class Parcel6 &#123; public Contents cont() &#123; return new Contents() &#123; private int i = 11; public int value() &#123; return i; &#125; &#125;; // Semicolon required in this case &#125; public static void main(String[] args) &#123; Parcel6 p = new Parcel6(); Contents c = p.cont(); &#125;&#125; /*这种奇怪的语法要表达的意思是：“创建从 Contents 衍生出来的匿名类的一个对象”。由 new表达式返回的句柄会自动上溯造型成一个Contents 句柄。匿名内部类的语法其实要表达的是：class MyContents implements Contents &#123; private int i = 11; public int value() &#123; return i; &#125;&#125;return new MyContents();*///当继承的基础类含有带参数的构造器时-------------------------public class Parcel7 &#123; public Wrapping wrap(int x) &#123; // Base constructor call: return new Wrapping(x) &#123; public int value() &#123; return super.value() * 47; &#125; &#125;; // Semicolon required &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Wrapping w = p.wrap(10); &#125;&#125;/*这里的匿名内部类可以调用构造函数*///下面是初始化匿名内部类中的字段例子public class Parcel8 &#123; // Argument must be final to use inside // anonymous inner class: public Destination dest(final String dest) &#123; return new Destination() &#123; private String label = dest; //^_^ public String readLabel() &#123; return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel8 p = new Parcel8(); Destination d = p.dest("Tanzania"); &#125;&#125;/*由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：*//*若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是我们将dest()的自变量设为final 的原因。*///使用构造快来，来实现匿名内部类的成员初始化public class Parcel9 &#123; public Destination dest(final String dest, final float price) &#123; return new Destination() &#123; private int cost; //----------------------------------------------------- // Instance initialization for each object: 这里使用实例初始化 &#123; cost = Math.round(price); if(cost &gt; 100) System.out.println("Over budget!"); &#125; //----------------------------------------------------- private String label = dest; public String readLabel() &#123; return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel9 p = new Parcel9(); Destination d = p.dest("Tanzania", 101.395F); System.out.println(d.readLabel()); &#125;&#125;/*结果如下Over budget!Tanzania实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们**不能对实例初始化模块进行过载**处理，所以只能拥有这些构建器的其中一个。*/ 内部类链接到外部类 创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Selector &#123; boolean end(); Object current(); void next();&#125;public class Sequence &#123; private Object[] o; private int next = 0; public Sequence(int size) &#123; o = new Object[size]; &#125; public void add(Object x) &#123; if(next &lt; o.length) &#123; o[next] = x; next++; &#125; &#125; private class SSelector implements Selector &#123; int i = 0; public boolean end() &#123; return i == o.length; &#125; public Object current() &#123; return o[i]; &#125; public void next() &#123; if(i &lt; o.length) i++; &#125; &#125; public Selector getSelector() &#123; return new SSelector(); &#125; public static void main(String[] args) &#123; Sequence s = new Sequence(10); for(int i = 0; i &lt; 10; i++) s.add(Integer.toString(i)); Selector sl = s.getSelector(); while(!sl.end()) &#123; System.out.println((String)sl.current()); sl.next(); &#125; &#125;&#125; static内部类 使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖于外围类的。 它不能使用任何外围类的非static成员变量和方法。 下面有个网上摘抄的demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class OuterClass &#123; private String sex; public static String name = "chenssy"; /** *静态内部类 */ static class InnerClass1&#123; /* 在静态内部类中可以存在静态成员 */ public static String _name1 = "chenssy_static"; public void display()&#123; /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println("OutClass name :" + name); &#125; &#125; /** * 非静态内部类 */ class InnerClass2&#123; /* 非静态内部类中不能存在静态成员 */ public String _name2 = "chenssy_inner"; /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display()&#123; System.out.println("OuterClass name：" + name); &#125; &#125; /** * @desc 外围类方法 */ public void display()&#123; /* 外围类访问静态内部类：内部类. */ System.out.println(InnerClass1._name1); /* 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 */ OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); /* 方位非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.display(); &#125;&#125; ---------------- Output: chenssy_static OutClass name :chenssy chenssy_inner OuterClass name：chenssy 通常，我们不在一个接口里设置任何代码，但 static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static 内部类只位于接口的命名空间内部： 1234567interface IInterface &#123; static class Inner &#123; int i, j, k; public Inner() &#123;&#125; void f() &#123;&#125; &#125; &#125; 引用外部类对象 有些时候，我们想告诉其他某些对象创建它某个内部类的一个对象。为达到这个目的，必须在 new表达式中提供指向其他外部类对象的一个句柄，就象下面这样： 12345678910111213141516171819202122public class Parcel11 &#123; class Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; public static void main(String[] args) &#123; Parcel11 p = new Parcel11(); // Must use instance of outer class // to create an instances of the inner class:----------注意外部类的引用 p Parcel11.Contents c = p.new Contents(); Parcel11.Destination d = p.new Destination("Tanzania"); &#125;&#125; 从内部类继承 当继承内部类时，有一个很重要的问题，内部类必须要在外部类初始化，并且有一个对象句柄才能使用，所以在这里，继承内部类后的类，在实例化时，要使的他与所继承类的外部类有联系，通过下面代码展现 12345678910111213class WithInner &#123; class Inner &#123;&#125;&#125;public class InheritInner extends WithInner.Inner &#123; //! InheritInner() &#123;&#125; // Won't compile InheritInner(WithInner wi) &#123; wi.super(); //super()调用 &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); //建立联系 &#125;&#125; 内部类继承覆盖 继承时，内部类的覆盖要明确指明,如：class Yolk extends Egg2.Yolk```,下面的书上的一个例子。12345678910111213141516171819202122232425262728293031323334353637383940```java class Egg2 &#123; protected class Yolk &#123; public Yolk() &#123; System.out.println(&quot;Egg2.Yolk()&quot;); &#125; public void f() &#123; System.out.println(&quot;Egg2.Yolk.f()&quot;); &#125; &#125; private Yolk y = new Yolk(); public Egg2() &#123; System.out.println(&quot;New Egg2()&quot;); &#125; public void insertYolk(Yolk yy) &#123; y = yy; &#125; public void g() &#123; y.f(); &#125; &#125; public class BigEgg2 extends Egg2 &#123; public class Yolk extends Egg2.Yolk &#123; public Yolk() &#123; System.out.println(&quot;BigEgg2.Yolk()&quot;); &#125; public void f() &#123; System.out.println(&quot;BigEgg2.Yolk.f()&quot;); &#125; &#125; public BigEgg2() &#123; insertYolk(new Yolk()); &#125; public static void main(String[] args) &#123; Egg2 e2 = new BigEgg2(); e2.g(); &#125; &#125; 方法 insertYolk()允许BigEgg2将它自己的某个 Yolk 对象上溯造型至 Egg2 的y 句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。 输出结果如下： Egg2.Yolk() New Egg2() Egg2.Yolk() BigEgg2.Yolk() BigEgg2.Yolk.f() 7.6.9 为什么要用内部类：控制框架（P192）自己看代码研究（记得调试观察） 构建器和多形性构建器的调用顺序 基础类的构建器肯定在一个衍生类的构建器中调用，而且逐渐向上链接，原因在于：检查对象是否得到了正确的构建。一个衍生类只能访问它自己的成员，不能访问基础类的成员（这些成员通常都具有private 属性）。只有基础类的构建器在初始化自己的元素时才知道正确的方法以及拥有适当的权限。 若我们没有明确指定对一个基础类构建器的调用，它就会“默默”地调用默认构建器。如果不存在默认构建器，编译器就会报告一个错误（若某个类没有构建器，编译器会自动组织一个默认构建器）。 下面是个例子 123456789101112131415161718192021222324252627282930313233343536373839class Meal &#123; Meal() &#123; System.out.println("Meal()"); &#125;&#125;class Bread &#123; Bread() &#123; System.out.println("Bread()"); &#125;&#125;class Cheese &#123; Cheese() &#123; System.out.println("Cheese()"); &#125;&#125;class Lettuce &#123; Lettuce() &#123; System.out.println("Lettuce()"); &#125;&#125;class Lunch extends Meal &#123; Lunch() &#123; System.out.println("Lunch()");&#125;&#125;class PortableLunch extends Lunch &#123; PortableLunch() &#123; System.out.println("PortableLunch()"); &#125;&#125;class Sandwich extends PortableLunch &#123; Bread b = new Bread(); Cheese c = new Cheese(); Lettuce l = new Lettuce(); Sandwich() &#123; System.out.println("Sandwich()"); &#125; public static void main(String[] args) &#123; new Sandwich(); &#125;&#125;//结果如下：//Meal()//Lunch()//PortableLunch()//Bread()//Cheese()//Lettuce()//Sandwich() 调用基础类构建器。这个步骤会不断重复下去，首先得到构建的是分级结构的根部，然后是下一个衍生类，等等。直到抵达最深一层的衍生类。 按声明顺序调用成员初始化模块。 调用衍生构建器的主体。 继承和 finalize() 通过合成，程序完结时，一定会调用finalize()释放。离衍生类最近的成员类先释放。 如果继承的父类，没有覆盖finalize()方法且没有调用super.finalize()，那衍生调用finalize后，父类不会在finalize。 例子在P199 一个关于初始化需要注意的问题 先看代码: 123456789101112131415161718192021222324252627282930313233abstract class Glyph &#123; abstract void draw(); Glyph() &#123; System.out.println("Glyph() before draw()"); draw(); System.out.println("Glyph() after draw()"); &#125;&#125;class RoundGlyph extends Glyph &#123; int radius = 1; RoundGlyph(int r) &#123; radius = r; System.out.println("RoundGlyph.RoundGlyph(), radius = " + radius); &#125; void draw() &#123; System.out.println("RoundGlyph.draw(), radius = " + radius); &#125;&#125;public class PolyConstructors &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125;结果如下：Glyph() before draw()RoundGlyph.draw(), radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(), radius = 5 子类调用父类构造器时，因为子类重写了抽象类的方法，而那时子类的成员并没被初始化。说以父类构造器调用会出现意想不到的错误。 一般不要再构造器中调用方法来初始化类。 在构建器内唯一能够安全调用的是在基础类中具有final 属性的那些方法（也适用于private方法，它们自动具有final 属性）。这些方法不能被覆盖，所以不会出现上述潜在的问题。]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多形性</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础 类再生(java编程思想)]]></title>
    <url>%2F2017%2F05%2F27%2FjavaBase-%E7%B1%BB%E5%86%8D%E7%94%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1 .关于合成与继承 合成：合成只需在新类里简单地置入对象句柄即可，更加灵活，对象会被置null值，基础数据类型置0或者false。 继承：在新类后面使用关键字extends加上一个基础类，则可完成继承，新类可以继承基础类的所有非private变量和方法。 一般合成与继承两种技术结合起来使用 只有在清楚知道继承在所有方法中最有效的前提下，才可考虑继承。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。 2 .final关键字 final数据：（1）编译期常数，它永远不会改变，对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型。无论static还是final字段，都只能存储一个数据，而且不得改变。（2）但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。 空白final：允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。 final自变量：允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。如下： 12345678void with(final Gizmo g) &#123; //! g = new Gizmo(); // Illegal g is final g.spin();&#125;void without(Gizmo g) &#123; g = new Gizmo(); // OK g not final g.spin();&#125; final方法：第一个是为方法“上锁”，防止任何继承类改变它的本来含义。第二是为程序执行的效率[p155]类内所有 private 方法都自动成为 final 。 final 类：整个类都是final（在它的定义前冠以 final 关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。 3 .继承初始化先看代码 1234567891011121314151617181920212223242526272829class Insect &#123; int i = 9; int j; Insect() &#123; prt("i = " + i + ", j = " + j); j = 39; &#125; static int x1 = prt("static Insect.x1 initialized"); static int prt(String s) &#123; System.out.println(s); return 47; &#125;&#125;public class Beetle extends Insect &#123; int k = prt("Beetle.k initialized"); Beetle() &#123; prt("k = " + k); prt("j = " + j); &#125; static int x2 =prt("static Beetle.x2 initialized"); static int prt(String s) &#123; System.out.println(s); return 63; &#125; public static void main(String[] args) &#123; prt("Beetle constructor"); Beetle b = new Beetle(); &#125;&#125; 在看结果 static Insect.x initialized static Beetle.x initialized Beetle constructor i = 9, j = 0 Beetle.k initialized k = 63 j = 39 父类静态变量（静态代码块，静态成员变量）–&gt; 子类静态变量（静态代码块，静态成员变量）–&gt;父类成员变量–&gt;子类成员变量–&gt;main函数–&gt;父类构造器–&gt;子类构造器]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>类再生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式 GOF-Factory-Method]]></title>
    <url>%2F2017%2F05%2F02%2FGOF-Factory-Method%2F</url>
    <content type="text"><![CDATA[工厂方法模式 （Factory Method）工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 Java研究组织Java设计模式之工厂方法模式 工厂方法模式分为三种1. 普通工厂模式 2. 多个工厂方法模式 3. 静态工厂方法模式 一,普通工厂模式: 建立一个工厂类，对实现了同一接口的一些类进行实例的创建。设计参考下图： 创建Sender接口 123public interface Sender &#123; public void Send(); &#125; 分别实现两个接口的类 123456 public class PhoneSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is phonesender!"); &#125; &#125; 123456 public class MessageSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is messagesender!"); &#125; &#125; 然后创建工厂类 123456789101112public class SendFactory &#123; public Sender produce(String type) &#123; if ("phone".equals(type)) &#123; return new MailSender(); &#125; else if ("msg".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("请输入正确的类型!"); return null; &#125; &#125; &#125; 创建测试方法 1234567 public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce("msg"); sender.Send(); &#125; &#125; 输出结果：this is messagesender! 二，多个工厂方法模式 是对普通工厂方法模式的改进，普通工厂方法模式中，字符串传递容易出错，可以通过多个工厂方法创建对象。参考图如下： 修改简单工厂模式中的SendFactory 12345678public class SendFactory &#123; public Sender producePhone()&#123; return new PhoneSender(); &#125; public Sender produceMessage()&#123; return new MessageSender(); &#125; &#125; 设计测试类 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMessage(); sender.Send(); &#125; &#125; 测试结果 输出结果：this is messagesender!]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404]]></title>
    <url>%2F2017%2F01%2F05%2F%2F404%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[上次服务器加wp的崩溃后，现在终于又有了，以后要写些东西了]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
</search>